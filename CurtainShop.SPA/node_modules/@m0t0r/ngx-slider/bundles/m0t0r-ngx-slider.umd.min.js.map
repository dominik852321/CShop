{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@m0t0r/ngx-slider/lib/interfaces/options.ts","ng://@m0t0r/ngx-slider/lib/interfaces/pointer-type.ts","ng://@m0t0r/ngx-slider/lib/interfaces/change-context.ts","ng://@m0t0r/ngx-slider/lib/helpers/value-helper.ts","ng://@m0t0r/ngx-slider/lib/helpers/compatibility-helper.ts","ng://@m0t0r/ngx-slider/lib/helpers/math-helper.ts","ng://@m0t0r/ngx-slider/lib/interfaces/event-listener.ts","ng://@m0t0r/ngx-slider/lib/helpers/event-listener-helper.ts","ng://@m0t0r/ngx-slider/lib/directives/slider-element.directive.ts","ng://@m0t0r/ngx-slider/lib/directives/slider-handle.directive.ts","ng://@m0t0r/ngx-slider/lib/directives/slider-label.directive.ts","ng://@m0t0r/ngx-slider/lib/slider/slider.component.ts","ng://@m0t0r/ngx-slider/lib/tooltip-wrapper/tooltip-wrapper.component.ts","ng://@m0t0r/ngx-slider/lib/slider/slider.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__values","o","m","Symbol","iterator","i","call","next","length","value","done","LabelType","Low","High","Floor","Ceil","TickValue","floor","ceil","step","minRange","maxRange","pushRange","minLimit","maxLimit","translate","combineLabels","getLegend","stepsArray","bindIndexForStepsArray","draggableRange","draggableRangeOnly","showSelectionBar","showSelectionBarEnd","showSelectionBarFromValue","showOuterSelectionBars","hidePointerLabels","hideLimitLabels","autoHideLimitLabels","readOnly","disabled","mouseEventsInterval","touchEventsInterval","inputEventsInterval","outputEventsInterval","showTicks","showTicksValues","tickStep","tickValueStep","ticksArray","ticksTooltip","ticksValuesTooltip","vertical","getSelectionBarColor","getTickColor","getPointerColor","keyboardSupport","scale","enforceStep","enforceRange","noSwitching","onlyBindHandles","rightToLeft","reversedControls","boundPointerLabels","logScale","customValueToPosition","customPositionToValue","precisionLimit","selectionBarGradient","ariaLabel","ariaLabelledBy","ariaLabelHigh","ariaLabelledByHigh","handleDimension","barDimension","animate","PointerType","Min","Max","ChangeContext","ValueHelper","isNullOrUndefined","linearValueToPosition","val","minVal","maxVal","logValueToPosition","Math","log","linearPositionToValue","percent","logPositionToValue","exp","findStepIndex","modelValue","differences","map","abs","minDifferenceIndex","index","CompatibilityHelper","isTouchEvent","event","undefined","TouchEvent","touches","isResizeObserverAvailable","ResizeObserver","MathHelper","roundToPrecisionLimit","toPrecision","clampToRange","min","max","EventListener","eventName","events","eventsSubscription","teardownCallback","EventListenerHelper","renderer","attachPassiveEventListener","nativeElement","callback","throttleInterval","detectPassiveEvents","hasSupport","attachEventListener","listener","Subject","observerCallback","addEventListener","passive","capture","removeEventListener","pipe","tap","throttleTime","leading","trailing","subscribe","detachEventListener","eventListener","unsubscribe","complete","listen","SliderElementDirective","elemRef","_position","_dimension","_alwaysHide","_vertical","_scale","opacity","visibility","left","bottom","height","width","eventListeners","eventListenerHelper","defineProperty","setAlwaysHide","hide","show","alwaysHide","isVisible","setVertical","setScale","setPosition","pos","round","calculateDimension","getBoundingClientRect","top","right","setDimension","dim","on","debounceInterval","push","onPassive","off","listenersToKeep","listenersToRemove","filter","listenersToRemove_1","listenersToRemove_1_1","Directive","args","selector","ElementRef","Renderer2","HostBinding","SliderHandleDirective","_this","_super","active","role","tabindex","ariaOrientation","ariaValueNow","ariaValueText","ariaValueMin","ariaValueMax","focus","SliderLabelDirective","_value","setValue","recalculateDimension","dimension","innerHTML","selected","style","tooltip","tooltipPlacement","valueTooltip","valueTooltipPlacement","legend","Dragging","difference","position","lowLimit","highLimit","ModelValues","compare","x","y","highValue","ModelChange","forceChange","InputModelChange","OutputModelChange","NGX_SLIDER_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","SliderComponent","multi","elementRef","changeDetectionRef","zone","valueChange","EventEmitter","highValueChange","options","Options","userChangeStart","userChange","userChangeEnd","initHasRun","inputModelChangeSubject","inputModelChangeSubscription","outputModelChangeSubject","outputModelChangeSubscription","viewLowValue","viewHighValue","viewOptions","handleHalfDimension","maxHandlePosition","currentTrackingPointer","currentFocusPointer","firstKeyDown","touchId","dragging","sliderElementVerticalClass","sliderElementAnimateClass","sliderElementDisabledAttr","barStyle","minPointerStyle","maxPointerStyle","fullBarTransparentClass","selectionBarDraggableClass","ticksUnderValuesClass","intermediateTicks","ticks","onMoveEventListener","onEndEventListener","resizeObserver","onTouchedCallback","onChangeCallback","manualRefresh","unsubscribeManualRefresh","manualRefreshSubscription","setTimeout","calculateViewDimensionsAndDetectChanges","triggerFocus","unsubscribeTriggerFocus","triggerFocusSubscription","pointerType","focusPointer","ngOnInit","assign","updateDisabledState","updateVerticalState","ngAfterViewInit","applyOptions","subscribeInputModelChangeSubject","subscribeOutputModelChangeSubject","renormaliseModelValues","modelValueToViewValue","range","manageElementsStyle","calculateViewDimensions","addAccessibility","updateCeilLabel","updateFloorLabel","initHandles","manageEventsBindings","subscribeResizeObserver","detectChanges","ngOnChanges","changes","onChangeOptions","internalChange","ngOnDestroy","unbindEvents","unsubscribeResizeObserver","unsubscribeInputModelChangeSubject","unsubscribeOutputModelChangeSubject","writeValue","obj","registerOnChange","registerOnTouched","setDisabledState","isDisabled","onResize","interval","distinctUntilChanged","modelChange","applyInputModelChange","publishOutputModelChange","observe","disconnect","unsubscribeOnMove","unsubscribeOnEnd","getPointerElement","minHandleElement","maxHandleElement","getCurrentTrackingValue","NaN","viewValueToModelValue","viewValue","getStepValue","sliderValue","applyViewChange","userEventInitiated","normalisedModelChange","normaliseModelValues","normalisationChange","updateLowHandle","valueToPosition","updateHighHandle","updateSelectionBar","updateTicksScale","updateAriaAttributes","updateCombinedLabel","emitOutputs","emit","getChangeContext","input","normalisedInput","roundStep","tempValue","previousModelValues","normalisedModelValues","previousInputEventsInterval","previousOutputEventsInterval","resetSlider","applyFloorCeilOptions","applyStepsArrayOptions","minValue","maxValue","Error","String","refocusPointerIfNeeded","onPointerFocus","updateScale","floorLabelElement","ceilLabelElement","hideLabelsForTicks","minHandleLabelElement","maxHandleLabelElement","combinedLabelElement","selectionBarElement","leftOuterSelectionBarElement","rightOuterSelectionBarElement","bindEvents","_b","getAllSliderElements","_c","element","fullBarElement","ticksElement","toString","handleWidth","getTicksArray","reverse","newTicks","translation","tick","Tick","isTickSelected","-webkit-transform","-moz-transform","-o-transform","-ms-transform","transform","getDisplayValue","center","updateHandles","which","newPos","getHandleLabelPos","labelType","labelDimension","nearHandlePos","endOfBarPos","backgroundColor","updateFloorAndCeilLabelsVisibility","floorLabelHidden","ceilLabelHidden","isMinLabelAtFloor","isLabelBelowFloorLabel","isMinLabelAtCeil","isLabelAboveCeilLabel","isMaxLabelAtCeil","isCombinedLabelAtFloor","isCombinedLabelAtCeil","hideCeil","hideFloor","label","floorPos","floorDim","ceilPos","ceilDim","isSelectionBarFromRight","positionForRange","centerPosition","offset","reversed","direction","backgroundImage","from","to","backgroundPosition","backgroundSize","color","lowDisplayValue","highDisplayValue","combinedLabelValue","customStep","steppedDifference","fn","positionToValue","getEventXY","targetTouchId","MouseEvent","clientY","clientX","touchIndex","identifier","getEventPosition","sliderElementBoundingRect","sliderPos","getNearestHandle","distanceMin","distanceMax","onBarStart","onStart","bindMove","bindEnd","simulateImmediateMove","simulateImmediateEnd","onDragStart","stopPropagation","preventDefault","pointerElement","onMoveCallback","e","onDragMove","onMove","document","onEndCallback","onEnd","changedTouches","fromTick","touchForThisSlider","newValue","ceilValue","floorValue","positionTrackingHandle","onPointerBlur","onKeyboardEvent","onKeyUp","pointer","getKeyActions","currentValue","valueRange","increaseStep","decreaseStep","increasePage","decreasePage","actions","UP","DOWN","LEFT","RIGHT","PAGEUP","PAGEDOWN","HOME","END","keyCode","action","38","40","37","39","33","34","36","35","actionValue","newMinValue","newMaxValue","positionTrackingBar","getMinValue","outOfBounds","isAbove","isRTL","getMaxValue","ceilLimit","floorLimit","floorHandleElement","ceilHandleElement","isUnderFloorLimit","isOverCeilLimit","applyMinMaxLimit","applyPushRange","applyMinMaxRange","oppositeValue","changeContext","Component","template","host","class","providers","ChangeDetectorRef","NgZone","Input","Output","ViewChild","read","static","ContentChild","HostListener","TooltipWrapperComponent","NgxSliderModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":";;;;;;;;;;;;;;;AAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GAkF5E,SAASK,EAASC,GACrB,IAAIC,EAAsB,mBAAXC,QAAyBF,EAAEE,OAAOC,UAAWC,EAAI,EAChE,OAAIH,EAAUA,EAAEI,KAAKL,GACd,CACHM,KAAM,WAEF,OADIN,GAAKI,GAAKJ,EAAEO,SAAQP,OAAI,GACrB,CAAEQ,MAAOR,GAAKA,EAAEI,KAAMK,MAAOT,SC9GpCU,EAAS,CAEnBC,IAAG,EAEHC,KAAI,EAEJC,MAAK,EAELC,KAAI,EAEJC,UAAS,wGA6BX,WAIEpB,KAAAqB,MAAiB,EAKjBrB,KAAAsB,KAAgB,KAKhBtB,KAAAuB,KAAgB,EAMhBvB,KAAAwB,SAAoB,KAMpBxB,KAAAyB,SAAoB,KAOpBzB,KAAA0B,WAAsB,EAKtB1B,KAAA2B,SAAoB,KAKpB3B,KAAA4B,SAAoB,KAKpB5B,KAAA6B,UAAgC,KAOhC7B,KAAA8B,cAAwC,KASxC9B,KAAA+B,UAAgC,KAUhC/B,KAAAgC,WAAsC,KAGtChC,KAAAiC,wBAAmC,EAKnCjC,KAAAkC,gBAA2B,EAK3BlC,KAAAmC,oBAA+B,EAG/BnC,KAAAoC,kBAA6B,EAG7BpC,KAAAqC,qBAAgC,EAKhCrC,KAAAsC,0BAAqC,KAKrCtC,KAAAuC,wBAAmC,EAGnCvC,KAAAwC,mBAA8B,EAG9BxC,KAAAyC,iBAA4B,EAG5BzC,KAAA0C,qBAAgC,EAGhC1C,KAAA2C,UAAqB,EAGrB3C,KAAA4C,UAAqB,EAKrB5C,KAAA6C,oBAA+B,GAK/B7C,KAAA8C,oBAA+B,GAK/B9C,KAAA+C,oBAA+B,IAK/B/C,KAAAgD,qBAAgC,IAGhChD,KAAAiD,WAAsB,EAGtBjD,KAAAkD,iBAA4B,EAI5BlD,KAAAmD,SAAoB,KAGpBnD,KAAAoD,cAAyB,EAMzBpD,KAAAqD,WAAwB,KAKxBrD,KAAAsD,aAA2C,KAG3CtD,KAAAuD,mBAAiD,KAMjDvD,KAAAwD,UAAqB,EASrBxD,KAAAyD,qBAAyE,KAGzEzD,KAAA0D,aAA2C,KAU3C1D,KAAA2D,gBAAwE,KAUxE3D,KAAA4D,iBAA4B,EAK5B5D,KAAA6D,MAAiB,EAMjB7D,KAAA8D,aAAwB,EAMxB9D,KAAA+D,cAAyB,EAGzB/D,KAAAgE,aAAwB,EAGxBhE,KAAAiE,iBAA4B,EAK5BjE,KAAAkE,aAAwB,EAUxBlE,KAAAmE,kBAA6B,EAG7BnE,KAAAoE,oBAA+B,EAG/BpE,KAAAqE,UAAqB,EAMrBrE,KAAAsE,sBAAkD,KAMlDtE,KAAAuE,sBAAkD,KAMlDvE,KAAAwE,eAA0B,GAK1BxE,KAAAyE,qBAAoD,KAGpDzE,KAAA0E,UAAqB,KAKrB1E,KAAA2E,eAA0B,KAG1B3E,KAAA4E,cAAyB,KAKzB5E,KAAA6E,mBAA8B,KAG9B7E,KAAA8E,gBAA2B,KAG3B9E,KAAA+E,aAAwB,KAGxB/E,KAAAgF,SAAoB,GCjVtB,IAAYC,EAAW,CAErBC,IAAG,EAEHC,IAAG,iCCHL,IAAAC,EAAA,aCGA,iBAAA,SAAAC,KAyCA,OAxCSA,EAAAC,kBAAP,SAAyBzE,GACvB,OAAOA,MAAAA,GAGFwE,EAAAE,sBAAP,SAA6BC,EAAaC,EAAgBC,GAExD,OAAQF,EAAMC,IADQC,EAASD,IAI1BJ,EAAAM,mBAAP,SAA0BH,EAAaC,EAAgBC,GAKrD,QAJAF,EAAMI,KAAKC,IAAIL,KACfC,EAASG,KAAKC,IAAIJ,OAClBC,EAASE,KAAKC,IAAIH,IACaD,IAI1BJ,EAAAS,sBAAP,SAA6BC,EAAiBN,EAAgBC,GAC5D,OAAOK,GAAWL,EAASD,GAAUA,GAGhCJ,EAAAW,mBAAP,SAA0BD,EAAiBN,EAAgBC,GACzDD,EAASG,KAAKC,IAAIJ,OAEZ5E,EAAgBkF,IADtBL,EAASE,KAAKC,IAAIH,IACwBD,GAAUA,EACpD,OAAOG,KAAKK,IAAIpF,IAGXwE,EAAAa,cAAP,SAAqBC,EAAoBnE,GAIvC,QAHMoE,EAAwBpE,EAAWqE,KAAG,SAAE9E,GAAuC,OAAAqE,KAAKU,IAAIH,EAAa5E,EAAKV,UAE5G0F,EAAqB,EAChBC,EAAQ,EAAGA,EAAQxE,EAAWpB,OAAQ4F,IACzCJ,EAAYI,KAAWJ,EAAYG,IAAuBH,EAAYI,GAASJ,EAAYG,KAC7FA,EAAqBC,GAIzB,OAAOD,GAEXlB,kBCxCA,SAAAoB,KAcA,OAZgBA,EAAAC,aAAd,SAA2BC,GACzB,YAAmCC,IAA/B,OAAgBC,WACXF,aAAiBE,gBAGDD,IAAlBD,EAAMG,SAIDL,EAAAM,0BAAd,WACE,YAA0CH,IAAnC,OAAgBI,gBAE3BP,kBCnBA,SAAAQ,KASA,OAPSA,EAAAC,sBAAP,SAA6BrG,EAAe2D,GAC1C,OAAU3D,EAAMsG,YAAY3C,IAGvByC,EAAAG,aAAP,SAAoBvG,EAAeQ,EAAeC,GAChD,OAAOsE,KAAKyB,IAAIzB,KAAK0B,IAAIzG,EAAOQ,GAAQC,IAE5C2F,KCRAM,EAAA,WACEvH,KAAAwH,UAAoB,KACpBxH,KAAAyH,OAAyB,KACzBzH,KAAA0H,mBAAmC,KACnC1H,KAAA2H,iBAA+B,MCKjC,iBACE,SAAAC,EAAoBC,GAAA7H,KAAA6H,SAAAA,EA0EtB,OAvESD,EAAA1H,UAAA4H,2BAAP,SAAkCC,EAAoBP,EAAmBQ,EACvCC,GAEhC,IAAuC,IAAnCC,EAAoBC,WACtB,OAAOnI,KAAKoI,oBAAoBL,EAAeP,EAAWQ,EAAUC,OAIhEI,EAA0B,IAAId,EACpCc,EAASb,UAAYA,EACrBa,EAASZ,OAAS,IAAIa,EAAAA,YAEhBC,EAAgB,SAA4B5B,GAChD0B,EAASZ,OAAO9G,KAAKgG,IAiBvB,OAfAoB,EAAcS,iBAAiBhB,EAAWe,EAAkB,CAACE,SAAS,EAAMC,SAAS,IAErFL,EAASV,iBAAgB,WACvBI,EAAcY,oBAAoBnB,EAAWe,EAAkB,CAACE,SAAS,EAAMC,SAAS,KAG1FL,EAASX,mBAAqBW,EAASZ,OACpCmB,KAAOvD,EAAYC,kBAAkB2C,GAElCY,EAAAA,KAAG,eADHC,EAAAA,aAAab,OAAkBrB,EAAW,CAAEmC,SAAS,EAAMC,UAAU,KAGxEC,WAAS,SAAEtC,GACVqB,EAASrB,MAGN0B,GAGFT,EAAA1H,UAAAgJ,oBAAP,SAA2BC,GACpB9D,EAAYC,kBAAkB6D,EAAczB,sBAC/CyB,EAAczB,mBAAmB0B,cACjCD,EAAczB,mBAAqB,MAGhCrC,EAAYC,kBAAkB6D,EAAc1B,UAC/C0B,EAAc1B,OAAO4B,WACrBF,EAAc1B,OAAS,MAGpBpC,EAAYC,kBAAkB6D,EAAcxB,oBAC/CwB,EAAcxB,mBACdwB,EAAcxB,iBAAmB,OAI9BC,EAAA1H,UAAAkI,oBAAP,SAA2BL,EAAoBP,EAAmBQ,EACvCC,OACnBI,EAA0B,IAAId,EACpCc,EAASb,UAAYA,EACrBa,EAASZ,OAAS,IAAIa,EAAAA,QAetB,OATAD,EAASV,iBAAmB3H,KAAK6H,SAASyB,OAAOvB,EAAeP,GAJ1C,SAA4Bb,GAChD0B,EAASZ,OAAO9G,KAAKgG,MAKvB0B,EAASX,mBAAqBW,EAASZ,OACpCmB,KAAOvD,EAAYC,kBAAkB2C,GAEhCY,EAAAA,KAAG,eADHC,EAAAA,aAAab,OAAkBrB,EAAW,CAAEmC,SAAS,EAAMC,UAAU,KAG1EC,WAAS,SAAEtC,GAAmBqB,EAASrB,MAEnC0B,GAEXT,sBC9BE,SAAA2B,EAAsBC,EAA+B3B,GAA/B7H,KAAAwJ,QAAAA,EAA+BxJ,KAAA6H,SAAAA,EA9C7C7H,KAAAyJ,UAAY,EAKZzJ,KAAA0J,WAAa,EAKb1J,KAAA2J,aAAc,EAKd3J,KAAA4J,WAAY,EAKZ5J,KAAA6J,OAAS,EAMjB7J,KAAA8J,QAAU,EAGV9J,KAAA+J,WAAa,UAGb/J,KAAAgK,KAAO,GAGPhK,KAAAiK,OAAS,GAGTjK,KAAAkK,OAAS,GAGTlK,KAAAmK,MAAQ,GAGAnK,KAAAoK,eAAkC,GAGxCpK,KAAKqK,oBAAsB,IAAIzC,EAAoB5H,KAAK6H,UA6G5D,OA3JErI,OAAA8K,eAAIf,EAAArJ,UAAA,WAAQ,KAAZ,WACE,OAAOF,KAAKyJ,2CAIdjK,OAAA8K,eAAIf,EAAArJ,UAAA,YAAS,KAAb,WACE,OAAOF,KAAK0J,4CAIdlK,OAAA8K,eAAIf,EAAArJ,UAAA,aAAU,KAAd,WACE,OAAOF,KAAK2J,6CAIdnK,OAAA8K,eAAIf,EAAArJ,UAAA,WAAQ,KAAZ,WACE,OAAOF,KAAK4J,2CAIdpK,OAAA8K,eAAIf,EAAArJ,UAAA,QAAK,KAAT,WACE,OAAOF,KAAK6J,wCA4BdN,EAAArJ,UAAAqK,cAAA,SAAcC,GACZxK,KAAK2J,YAAca,EAEjBxK,KAAK+J,WADHS,EACgB,SAEA,WAItBjB,EAAArJ,UAAAsK,KAAA,WACExK,KAAK8J,QAAU,GAGjBP,EAAArJ,UAAAuK,KAAA,WACMzK,KAAK0K,aAIT1K,KAAK8J,QAAU,IAGjBP,EAAArJ,UAAAyK,UAAA,WACE,OAAI3K,KAAK0K,YAGe,IAAjB1K,KAAK8J,SAGdP,EAAArJ,UAAA0K,YAAA,SAAYpH,GACVxD,KAAK4J,UAAYpG,EACbxD,KAAK4J,WACP5J,KAAKgK,KAAO,GACZhK,KAAKmK,MAAQ,KAEbnK,KAAKiK,OAAS,GACdjK,KAAKkK,OAAS,KAIlBX,EAAArJ,UAAA2K,SAAA,SAAShH,GACP7D,KAAK6J,OAAShG,GAIhB0F,EAAArJ,UAAA4K,YAAA,SAAYC,GACV/K,KAAKyJ,UAAYsB,EACb/K,KAAK4J,UACP5J,KAAKiK,OAASrE,KAAKoF,MAAMD,GAAO,KAEhC/K,KAAKgK,KAAOpE,KAAKoF,MAAMD,GAAO,MAKlCxB,EAAArJ,UAAA+K,mBAAA,eACQzF,EAAkBxF,KAAKkL,wBACzBlL,KAAKwD,SACPxD,KAAK0J,YAAclE,EAAIyE,OAASzE,EAAI2F,KAAOnL,KAAK6D,MAEhD7D,KAAK0J,YAAclE,EAAI4F,MAAQ5F,EAAIwE,MAAQhK,KAAK6D,OAKpD0F,EAAArJ,UAAAmL,aAAA,SAAaC,GACXtL,KAAK0J,WAAa4B,EACdtL,KAAK4J,UACP5J,KAAKkK,OAAStE,KAAKoF,MAAMM,GAAO,KAEhCtL,KAAKmK,MAAQvE,KAAKoF,MAAMM,GAAO,MAInC/B,EAAArJ,UAAAgL,sBAAA,WACE,OAAOlL,KAAKwJ,QAAQzB,cAAcmD,yBAGpC3B,EAAArJ,UAAAqL,GAAA,SAAG/D,EAAmBQ,EAAgCwD,OAC9CnD,EAA0BrI,KAAKqK,oBAAoBjC,oBACvDpI,KAAKwJ,QAAQzB,cAAeP,EAAWQ,EAAUwD,GACnDxL,KAAKoK,eAAeqB,KAAKpD,IAG3BkB,EAAArJ,UAAAwL,UAAA,SAAUlE,EAAmBQ,EAAgCwD,OACrDnD,EAA0BrI,KAAKqK,oBAAoBvC,2BACvD9H,KAAKwJ,QAAQzB,cAAeP,EAAWQ,EAAUwD,GACnDxL,KAAKoK,eAAeqB,KAAKpD,IAG3BkB,EAAArJ,UAAAyL,IAAA,SAAInE,WACEoE,EACAC,EACCxG,EAAYC,kBAAkBkC,IAIjCoE,EAAkB,GAClBC,EAAoB7L,KAAKoK,iBAJzBwB,EAAkB5L,KAAKoK,eAAe0B,QAAM,SAAEnF,GAAyB,OAAAA,EAAMa,YAAcA,KAC3FqE,EAAoB7L,KAAKoK,eAAe0B,QAAM,SAAEnF,GAAyB,OAAAA,EAAMa,YAAcA,UAM/F,IAAuB,IAAAuE,EAAA3L,EAAAyL,GAAiBG,EAAAD,EAAApL,QAAAqL,EAAAlL,KAAAkL,EAAAD,EAAApL,OAAE,CAArC,IAAM0H,EAAQ2D,EAAAnL,MACjBb,KAAKqK,oBAAoBnB,oBAAoBb,qGAG/CrI,KAAKoK,eAAiBwB,uBA9JzBK,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,kEANQC,EAAAA,kBAAYC,EAAAA,8CAkC7BC,EAAAA,YAAWJ,KAAA,CAAC,qCAGZI,EAAAA,YAAWJ,KAAA,CAAC,kCAGZI,EAAAA,YAAWJ,KAAA,CAAC,8BAGZI,EAAAA,YAAWJ,KAAA,CAAC,gCAGZI,EAAAA,YAAWJ,KAAA,CAAC,+BAGZI,EAAAA,YAAWJ,KAAA,CAAC,kBAoHf3C,uBC7HE,SAAAgD,EAAY/C,EAAqB3B,GAAjC,IAAA2E,EACEC,EAAA/L,KAAAV,KAAMwJ,EAAS3B,IAAS7H,YAlC1BwM,EAAAE,QAAS,EAGTF,EAAAG,KAAO,GAGPH,EAAAI,SAAW,GAGXJ,EAAAK,gBAAkB,GAGlBL,EAAA9H,UAAY,GAGZ8H,EAAA7H,eAAiB,GAGjB6H,EAAAM,aAAe,GAGfN,EAAAO,cAAgB,GAGhBP,EAAAQ,aAAe,GAGfR,EAAAS,aAAe,KASjB,OAtC2CnN,EAAAyM,EAAAE,GA+BzCF,EAAArM,UAAAgN,MAAA,WACElN,KAAKwJ,QAAQzB,cAAcmF,6BAnC9BjB,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,iEAJQC,EAAAA,kBAAYC,EAAAA,6CAO7BC,EAAAA,YAAWJ,KAAA,CAAC,yCAGZI,EAAAA,YAAWJ,KAAA,CAAC,+BAGZI,EAAAA,YAAWJ,KAAA,CAAC,0CAGZI,EAAAA,YAAWJ,KAAA,CAAC,4CAGZI,EAAAA,YAAWJ,KAAA,CAAC,2CAGZI,EAAAA,YAAWJ,KAAA,CAAC,8CAGZI,EAAAA,YAAWJ,KAAA,CAAC,6CAGZI,EAAAA,YAAWJ,KAAA,CAAC,6CAGZI,EAAAA,YAAWJ,KAAA,CAAC,4CAGZI,EAAAA,YAAWJ,KAAA,CAAC,yBAUfK,GAtC2ChD,qBCQzC,SAAA4D,EAAY3D,EAAqB3B,GAAjC,IAAA2E,EACEC,EAAA/L,KAAAV,KAAMwJ,EAAS3B,IAAS7H,YANlBwM,EAAAY,OAAiB,OA2B3B,OA7B0CtN,EAAAqN,EAAAV,GAGxCjN,OAAA8K,eAAI6C,EAAAjN,UAAA,QAAK,KAAT,WACE,OAAOF,KAAKoN,wCAOdD,EAAAjN,UAAAmN,SAAA,SAASxM,OACHyM,GAAuB,GAEtBtN,KAAK0K,aACLrF,EAAYC,kBAAkBtF,KAAKa,QACnCb,KAAKa,MAAMD,SAAWC,EAAMD,QAC3BZ,KAAKa,MAAMD,OAAS,GAAwB,IAAnBZ,KAAKuN,aAClCD,GAAuB,GAGzBtN,KAAKoN,OAASvM,EACdb,KAAKwJ,QAAQzB,cAAcyF,UAAY3M,EAGnCyM,GACFtN,KAAKiL,0CA7BVgB,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,gEALQC,EAAAA,kBAAYC,EAAAA,aAoChCc,GA7B0C5D,SCiD1C,WACEvJ,KAAAyN,UAAW,EACXzN,KAAA0N,MAAa,GACb1N,KAAA2N,QAAkB,KAClB3N,KAAA4N,iBAA2B,KAC3B5N,KAAAa,MAAgB,KAChBb,KAAA6N,aAAuB,KACvB7N,KAAA8N,sBAAgC,KAChC9N,KAAA+N,OAAiB,MAGnB,IAAAC,EAAA,WACEhO,KAAA0M,QAAS,EACT1M,KAAAa,MAAQ,EACRb,KAAAiO,WAAa,EACbjO,KAAAkO,SAAW,EACXlO,KAAAmO,SAAW,EACXnO,KAAAoO,UAAY,GAGd,IAAAC,EAAA,WAAA,SAAAA,KAaA,OATgBA,EAAAC,QAAd,SAAsBC,EAAiBC,GACrC,QAAInJ,EAAYC,kBAAkBiJ,KAAMlJ,EAAYC,kBAAkBkJ,MAGlEnJ,EAAYC,kBAAkBiJ,KAAOlJ,EAAYC,kBAAkBkJ,KAGhED,EAAE1N,QAAU2N,EAAE3N,OAAS0N,EAAEE,YAAcD,EAAEC,aAEpDJ,EAbA,GAeA,IAAAK,EAAA,SAAAjC,GAAA,SAAAiC,mDAgBA,OAhB0B5O,EAAA4O,EAAAjC,GAKViC,EAAAJ,QAAd,SAAsBC,EAAiBC,GACrC,QAAInJ,EAAYC,kBAAkBiJ,KAAMlJ,EAAYC,kBAAkBkJ,MAGlEnJ,EAAYC,kBAAkBiJ,KAAOlJ,EAAYC,kBAAkBkJ,KAGhED,EAAE1N,QAAU2N,EAAE3N,OACd0N,EAAEE,YAAcD,EAAEC,WAClBF,EAAEI,cAAgBH,EAAEG,eAE/BD,EAhBA,CAA0BL,IAkB1B,SAAA5B,GAAA,SAAAmC,mDAA+B9O,EAAA8O,EAAAnC,GAA/B,CAA+BiC,IAI/B,SAAAjC,GAAA,SAAAoC,mDAAgC/O,EAAA+O,EAAApC,GAAhC,CAAgCiC,OAI1BI,EAAyC,CAC7CC,QAASC,EAAAA,kBAETC,YAAaC,EAAAA,YAAU,WAAO,OAAAC,KAC9BC,OAAO,GAITD,EAAA,WAmME,SAAAA,EAA2BtH,EACAwH,EACAC,EACAC,GAHAvP,KAAA6H,SAAAA,EACA7H,KAAAqP,WAAAA,EACArP,KAAAsP,mBAAAA,EACAtP,KAAAuP,KAAAA,EA3LpBvP,KAAAa,MAAgB,KAGhBb,KAAAwP,YAAoC,IAAIC,EAAAA,aAIxCzP,KAAAyO,UAAoB,KAGpBzO,KAAA0P,gBAAwC,IAAID,EAAAA,aAK5CzP,KAAA2P,QAAmB,IAAIC,EAIvB5P,KAAA6P,gBAA+C,IAAIJ,EAAAA,aAInDzP,KAAA8P,WAA0C,IAAIL,EAAAA,aAI9CzP,KAAA+P,cAA6C,IAAIN,EAAAA,aA4BhDzP,KAAAgQ,YAAa,EAIbhQ,KAAAiQ,wBAAqD,IAAI3H,EAAAA,QACzDtI,KAAAkQ,6BAA6C,KAI7ClQ,KAAAmQ,yBAAuD,IAAI7H,EAAAA,QAC3DtI,KAAAoQ,8BAA8C,KAG9CpQ,KAAAqQ,aAAuB,KAEvBrQ,KAAAsQ,cAAwB,KAExBtQ,KAAAuQ,YAAuB,IAAIX,EAG3B5P,KAAAwQ,oBAAsB,EAEtBxQ,KAAAyQ,kBAAoB,EAGpBzQ,KAAA0Q,uBAAsC,KAEtC1Q,KAAA2Q,oBAAmC,KAEnC3Q,KAAA4Q,cAAe,EAEf5Q,KAAA6Q,QAAkB,KAElB7Q,KAAA8Q,SAAqB,IAAI9C,EA0D1BhO,KAAA+Q,4BAA6B,EAE7B/Q,KAAAgR,2BAA4B,EAE5BhR,KAAAiR,0BAAoC,KAGpCjR,KAAAkR,SAAgB,GAChBlR,KAAAmR,gBAAuB,GACvBnR,KAAAoR,gBAAuB,GACvBpR,KAAAqR,yBAA0B,EAC1BrR,KAAAsR,4BAA6B,EAC7BtR,KAAAuR,uBAAwB,EASvBvR,KAAAwR,mBAAoB,EAErBxR,KAAAyR,MAAgB,GAGfzR,KAAAqK,oBAA2C,KAC3CrK,KAAA0R,oBAAqC,KACrC1R,KAAA2R,mBAAoC,KAGpC3R,KAAA4R,eAAiC,KAGjC5R,KAAA6R,kBAA0C,KAC1C7R,KAAA8R,iBAAyC,KAO/C9R,KAAKqK,oBAAsB,IAAIzC,EAAoB5H,KAAK6H,UAq5D5D,OAljEErI,OAAA8K,eAAa6E,EAAAjP,UAAA,gBAAa,KAA1B,SAA2B6R,GAA3B,IAAAvF,EAAAxM,KACEA,KAAKgS,2BAELhS,KAAKiS,0BAA4BF,EAAc9I,WAAS,WACtDiJ,YAAU,WAAO,OAAA1F,EAAK2F,iFAM1B3S,OAAA8K,eAAa6E,EAAAjP,UAAA,eAAY,KAAzB,SAA0BkS,GAA1B,IAAA5F,EAAAxM,KACEA,KAAKqS,0BAELrS,KAAKsS,yBAA2BF,EAAanJ,WAAS,SAAEsJ,GACtD/F,EAAKgG,aAAaD,uCAKtB/S,OAAA8K,eAAW6E,EAAAjP,UAAA,QAAK,KAAhB,WACE,OAAQmF,EAAYC,kBAAkBtF,KAAKa,SAAWwE,EAAYC,kBAAkBtF,KAAKyO,4CA8G3FjP,OAAA8K,eAAW6E,EAAAjP,UAAA,YAAS,KAApB,WACE,OAAOF,KAAKuQ,YAAYtN,2CA8BnBkM,EAAAjP,UAAAuS,SAAP,WACEzS,KAAKuQ,YAAc,IAAIX,EACvBpQ,OAAOkT,OAAO1S,KAAKuQ,YAAavQ,KAAK2P,SAKrC3P,KAAK2S,sBACL3S,KAAK4S,uBAIAzD,EAAAjP,UAAA2S,gBAAP,WACE7S,KAAK8S,eAEL9S,KAAK+S,iCAAiC/S,KAAKuQ,YAAYxN,qBACvD/C,KAAKgT,kCAAkChT,KAAKuQ,YAAYvN,sBAGxDhD,KAAKiT,yBAELjT,KAAKqQ,aAAerQ,KAAKkT,sBAAsBlT,KAAKa,OAChDb,KAAKmT,MACPnT,KAAKsQ,cAAgBtQ,KAAKkT,sBAAsBlT,KAAKyO,WAErDzO,KAAKsQ,cAAgB,KAGvBtQ,KAAK4S,sBACL5S,KAAKoT,sBACLpT,KAAK2S,sBACL3S,KAAKqT,0BACLrT,KAAKsT,mBACLtT,KAAKuT,kBACLvT,KAAKwT,mBACLxT,KAAKyT,cACLzT,KAAK0T,uBAEL1T,KAAK2T,0BAEL3T,KAAKgQ,YAAa,EAGlBhQ,KAAKsP,mBAAmBsE,iBAInBzE,EAAAjP,UAAA2T,YAAP,SAAmBC,GAEZzO,EAAYC,kBAAkBwO,EAAQnE,UACzC3P,KAAK+T,kBAIF1O,EAAYC,kBAAkBwO,EAAQjT,QACtCwE,EAAYC,kBAAkBwO,EAAQrF,YACzCzO,KAAKiQ,wBAAwBtP,KAAK,CAChCE,MAAOb,KAAKa,MACZ4N,UAAWzO,KAAKyO,UAChBE,aAAa,EACbqF,gBAAgB,KAMf7E,EAAAjP,UAAA+T,YAAP,WACEjU,KAAKkU,eAELlU,KAAKmU,4BACLnU,KAAKoU,qCACLpU,KAAKqU,sCACLrU,KAAKgS,2BACLhS,KAAKqS,2BAIAlD,EAAAjP,UAAAoU,WAAP,SAAkBC,GACZA,aAAe5U,OACjBK,KAAKa,MAAQ0T,EAAI,GACjBvU,KAAKyO,UAAY8F,EAAI,IAErBvU,KAAKa,MAAQ0T,EAIfvU,KAAKiQ,wBAAwBtP,KAAK,CAChCE,MAAOb,KAAKa,MACZ4N,UAAWzO,KAAKyO,UAChBE,aAAa,EACbqF,gBAAgB,KAKb7E,EAAAjP,UAAAsU,iBAAP,SAAwB1C,GACtB9R,KAAK8R,iBAAmBA,GAInB3C,EAAAjP,UAAAuU,kBAAP,SAAyB5C,GACvB7R,KAAK6R,kBAAoBA,GAIpB1C,EAAAjP,UAAAwU,iBAAP,SAAwBC,GACtB3U,KAAKuQ,YAAY3N,SAAW+R,EAC5B3U,KAAK2S,uBAIAxD,EAAAjP,UAAA0U,SADP,SACgBjO,GACd3G,KAAKmS,2CAGChD,EAAAjP,UAAA6S,iCAAR,SAAyC8B,GAAzC,IAAArI,EAAAxM,KACEA,KAAKkQ,6BAA+BlQ,KAAKiQ,wBACxCrH,KACCkM,EAAAA,qBAAqBpG,EAAYJ,SAGjCxC,EAAAA,QAAM,SAAEiJ,GAAkC,OAACA,EAAYpG,cAAgBoG,EAAYf,kBACjF3O,EAAYC,kBAAkBuP,GAE1BhM,EAAAA,KAAG,eADHC,EAAAA,aAAa+L,OAAUjO,EAAW,CAAEmC,SAAS,EAAMC,UAAU,KAGpEC,WAAS,SAAE8L,GAAkC,OAAAvI,EAAKwI,sBAAsBD,OAGnE5F,EAAAjP,UAAA8S,kCAAR,SAA0C6B,GAA1C,IAAArI,EAAAxM,KACEA,KAAKoQ,8BAAgCpQ,KAAKmQ,yBACvCvH,KACCkM,EAAAA,qBAAqBpG,EAAYJ,SAC/BjJ,EAAYC,kBAAkBuP,GAE5BhM,EAAAA,KAAG,eADHC,EAAAA,aAAa+L,OAAUjO,EAAW,CAAEmC,SAAS,EAAMC,UAAU,KAGlEC,WAAS,SAAE8L,GAAmC,OAAAvI,EAAKyI,yBAAyBF,OAGzE5F,EAAAjP,UAAAyT,wBAAR,WAAA,IAAAnH,EAAAxM,KACMyG,EAAoBM,8BACtB/G,KAAK4R,eAAiB,IAAI5K,gBAAc,WAAa,OAAAwF,EAAK2F,6CAC1DnS,KAAK4R,eAAesD,QAAQlV,KAAKqP,WAAWtH,iBAIxCoH,EAAAjP,UAAAiU,0BAAR,WACM1N,EAAoBM,6BAAuD,OAAxB/G,KAAK4R,iBAC1D5R,KAAK4R,eAAeuD,aACpBnV,KAAK4R,eAAiB,OAIlBzC,EAAAjP,UAAAkV,kBAAR,WACO/P,EAAYC,kBAAkBtF,KAAK0R,uBACtC1R,KAAKqK,oBAAoBnB,oBAAoBlJ,KAAK0R,qBAClD1R,KAAK0R,oBAAsB,OAIvBvC,EAAAjP,UAAAmV,iBAAR,WACOhQ,EAAYC,kBAAkBtF,KAAK2R,sBACtC3R,KAAKqK,oBAAoBnB,oBAAoBlJ,KAAK2R,oBAClD3R,KAAK2R,mBAAqB,OAItBxC,EAAAjP,UAAAkU,mCAAR,WACO/O,EAAYC,kBAAkBtF,KAAKkQ,gCACtClQ,KAAKkQ,6BAA6B9G,cAClCpJ,KAAKkQ,6BAA+B,OAIhCf,EAAAjP,UAAAmU,oCAAR,WACOhP,EAAYC,kBAAkBtF,KAAKoQ,iCACtCpQ,KAAKoQ,8BAA8BhH,cACnCpJ,KAAKoQ,8BAAgC,OAIjCjB,EAAAjP,UAAA8R,yBAAR,WACO3M,EAAYC,kBAAkBtF,KAAKiS,6BACtCjS,KAAKiS,0BAA0B7I,cAC/BpJ,KAAKiS,0BAA4B,OAI7B9C,EAAAjP,UAAAmS,wBAAR,WACOhN,EAAYC,kBAAkBtF,KAAKsS,4BACtCtS,KAAKsS,yBAAyBlJ,cAC9BpJ,KAAKsS,yBAA2B,OAI5BnD,EAAAjP,UAAAoV,kBAAR,SAA0B/C,GACxB,OAAIA,IAAgBtN,EAAYC,IACvBlF,KAAKuV,iBACHhD,IAAgBtN,EAAYE,IAC9BnF,KAAKwV,iBAEP,MAGDrG,EAAAjP,UAAAuV,wBAAR,WACE,OAAIzV,KAAK0Q,yBAA2BzL,EAAYC,IACvClF,KAAKqQ,aACHrQ,KAAK0Q,yBAA2BzL,EAAYE,IAC9CnF,KAAKsQ,cAEP,MAGDnB,EAAAjP,UAAAgT,sBAAR,SAA8B/M,GAC5B,OAAId,EAAYC,kBAAkBa,GACzBuP,IAGJrQ,EAAYC,kBAAkBtF,KAAKuQ,YAAYvO,aAAgBhC,KAAKuQ,YAAYtO,wBAG7EkE,EAFCd,EAAYa,eAAeC,EAAYnG,KAAKuQ,YAAYvO,aAK3DmN,EAAAjP,UAAAyV,sBAAR,SAA8BC,GAC5B,OAAKvQ,EAAYC,kBAAkBtF,KAAKuQ,YAAYvO,aAAgBhC,KAAKuQ,YAAYtO,uBAG9E2T,EAFE5V,KAAK6V,aAAaD,IAKrBzG,EAAAjP,UAAA2V,aAAR,SAAqBC,OACbvU,EAA6BvB,KAAKuQ,YAAYvO,WAAW8T,GAC/D,OAASzQ,EAAYC,kBAAkB/D,GAAsBmU,IAAbnU,EAAKV,OAG/CsO,EAAAjP,UAAA6V,gBAAR,WACE/V,KAAKa,MAAQb,KAAK2V,sBAAsB3V,KAAKqQ,cACzCrQ,KAAKmT,QACPnT,KAAKyO,UAAYzO,KAAK2V,sBAAsB3V,KAAKsQ,gBAGnDtQ,KAAKmQ,yBAAyBxP,KAAK,CACjCE,MAAOb,KAAKa,MACZ4N,UAAWzO,KAAKyO,UAChBuH,oBAAoB,EACpBrH,aAAa,IAOf3O,KAAKiQ,wBAAwBtP,KAAK,CAChCE,MAAOb,KAAKa,MACZ4N,UAAWzO,KAAKyO,UAChBE,aAAa,EACbqF,gBAAgB,KAKZ7E,EAAAjP,UAAA8U,sBAAR,SAA8BD,OACtBkB,EAAqCjW,KAAKkW,qBAAqBnB,GAG/DoB,GAAgC9H,EAAYC,QAAQyG,EAAakB,GACnEE,IACFnW,KAAKa,MAAQoV,EAAsBpV,MACnCb,KAAKyO,UAAYwH,EAAsBxH,WAGzCzO,KAAKqQ,aAAerQ,KAAKkT,sBAAsB+C,EAAsBpV,OACjEb,KAAKmT,MACPnT,KAAKsQ,cAAgBtQ,KAAKkT,sBAAsB+C,EAAsBxH,WAEtEzO,KAAKsQ,cAAgB,KAGvBtQ,KAAKoW,gBAAgBpW,KAAKqW,gBAAgBrW,KAAKqQ,eAC3CrQ,KAAKmT,OACPnT,KAAKsW,iBAAiBtW,KAAKqW,gBAAgBrW,KAAKsQ,gBAElDtQ,KAAKuW,qBACLvW,KAAKwW,mBACLxW,KAAKyW,uBACDzW,KAAKmT,OACPnT,KAAK0W,sBAKP1W,KAAKmQ,yBAAyBxP,KAAK,CACjCE,MAAOoV,EAAsBpV,MAC7B4N,UAAWwH,EAAsBxH,UACjCE,YAAawH,EACbH,oBAAoB,KAKhB7G,EAAAjP,UAAA+U,yBAAR,SAAiCF,GAAjC,IAAAvI,EAAAxM,KACQ2W,EAAW,WACfnK,EAAKgD,YAAYoH,KAAK7B,EAAYlU,OAC9B2L,EAAK2G,OACP3G,EAAKkD,gBAAgBkH,KAAK7B,EAAYtG,WAGnCpJ,EAAYC,kBAAkBkH,EAAKsF,oBAClCtF,EAAK2G,MACP3G,EAAKsF,iBAAiB,CAACiD,EAAYlU,MAAOkU,EAAYtG,YAEtDjC,EAAKsF,iBAAiBiD,EAAYlU,QAGjCwE,EAAYC,kBAAkBkH,EAAKqF,qBAClCrF,EAAK2G,MACP3G,EAAKqF,kBAAkB,CAACkD,EAAYlU,MAAOkU,EAAYtG,YAEvDjC,EAAKqF,kBAAkBkD,EAAYlU,SAKrCkU,EAAYiB,oBAEdW,IACA3W,KAAK8P,WAAW8G,KAAK5W,KAAK6W,qBAI1B3E,YAAU,WAASyE,QAIfxH,EAAAjP,UAAAgW,qBAAR,SAA6BY,OACrBC,EAA+B,IAAI1I,EAYzC,GAXA0I,EAAgBlW,MAAQiW,EAAMjW,MAC9BkW,EAAgBtI,UAAYqI,EAAMrI,UAE9BzO,KAAKuQ,YAAYzM,cACnBiT,EAAgBlW,MAAQb,KAAKgX,UAAUD,EAAgBlW,OACnDb,KAAKmT,QACP4D,EAAgBtI,UAAYzO,KAAKgX,UAAUD,EAAgBtI,cAK1DpJ,EAAYC,kBAAkBtF,KAAKuQ,YAAYvO,cAAgBhC,KAAKuQ,YAAYxM,aACnF,OAAOgT,EAUT,GAPAA,EAAgBlW,MAAQoG,EAAWG,aAAa2P,EAAgBlW,MAAOb,KAAKuQ,YAAYlP,MAAOrB,KAAKuQ,YAAYjP,MAE5GtB,KAAKmT,QACP4D,EAAgBtI,UAAYxH,EAAWG,aAAa2P,EAAgBtI,UAAWzO,KAAKuQ,YAAYlP,MAAOrB,KAAKuQ,YAAYjP,OAItHtB,KAAKmT,OAAS2D,EAAMjW,MAAQiW,EAAMrI,UAGpC,GAAIzO,KAAKuQ,YAAYvM,YACnB+S,EAAgBlW,MAAQkW,EAAgBtI,cACnC,KACCwI,EAAoBH,EAAMjW,MAChCkW,EAAgBlW,MAAQiW,EAAMrI,UAC9BsI,EAAgBtI,UAAYwI,EAIhC,OAAOF,GAGD5H,EAAAjP,UAAA+S,uBAAR,eACQiE,EAAmC,CACvCrW,MAAOb,KAAKa,MACZ4N,UAAWzO,KAAKyO,WAEZ0I,EAAqCnX,KAAKkW,qBAAqBgB,GAChE7I,EAAYC,QAAQ6I,EAAuBD,KAC9ClX,KAAKa,MAAQsW,EAAsBtW,MACnCb,KAAKyO,UAAY0I,EAAsB1I,UAEvCzO,KAAKmQ,yBAAyBxP,KAAK,CACjCE,MAAOb,KAAKa,MACZ4N,UAAWzO,KAAKyO,UAChBE,aAAa,EACbqH,oBAAoB,MAKlB7G,EAAAjP,UAAA6T,gBAAR,WACE,GAAK/T,KAAKgQ,WAAV,KAIMoH,EAAsCpX,KAAKuQ,YAAYxN,oBACvDsU,EAAuCrX,KAAKuQ,YAAYvN,qBAE9DhD,KAAK8S,eAEDsE,IAAgCpX,KAAKuQ,YAAYxN,sBACnD/C,KAAKoU,qCACLpU,KAAK+S,iCAAiC/S,KAAKuQ,YAAYxN,sBAGrDsU,IAAiCrX,KAAKuQ,YAAYvN,uBACpDhD,KAAKoU,qCACLpU,KAAK+S,iCAAiC/S,KAAKuQ,YAAYvN,uBAIzDhD,KAAKiT,yBAELjT,KAAKqQ,aAAerQ,KAAKkT,sBAAsBlT,KAAKa,OAChDb,KAAKmT,MACPnT,KAAKsQ,cAAgBtQ,KAAKkT,sBAAsBlT,KAAKyO,WAErDzO,KAAKsQ,cAAgB,KAGvBtQ,KAAKsX,gBAICnI,EAAAjP,UAAA4S,aAAR,WAkCE,GAjCA9S,KAAKuQ,YAAc,IAAIX,EACvBpQ,OAAOkT,OAAO1S,KAAKuQ,YAAavQ,KAAK2P,SAErC3P,KAAKuQ,YAAYrO,eAAiBlC,KAAKmT,OAASnT,KAAKuQ,YAAYrO,eACjElC,KAAKuQ,YAAYpO,mBAAqBnC,KAAKmT,OAASnT,KAAKuQ,YAAYpO,mBACjEnC,KAAKuQ,YAAYpO,qBACnBnC,KAAKuQ,YAAYrO,gBAAiB,GAGpClC,KAAKuQ,YAAYtN,UAAYjD,KAAKuQ,YAAYtN,WAC5CjD,KAAKuQ,YAAYrN,kBAChBmC,EAAYC,kBAAkBtF,KAAKuQ,YAAYlN,aAC9CrD,KAAKuQ,YAAYtN,WAChBoC,EAAYC,kBAAkBtF,KAAKuQ,YAAYpN,WAAckC,EAAYC,kBAAkBtF,KAAKuQ,YAAYlN,cAC/GrD,KAAKwR,mBAAoB,GAG3BxR,KAAKuQ,YAAYnO,iBAAmBpC,KAAKuQ,YAAYnO,kBACnDpC,KAAKuQ,YAAYlO,sBAChBgD,EAAYC,kBAAkBtF,KAAKuQ,YAAYjO,2BAE7C+C,EAAYC,kBAAkBtF,KAAKuQ,YAAYvO,YAGlDhC,KAAKuX,wBAFLvX,KAAKwX,yBAKHnS,EAAYC,kBAAkBtF,KAAKuQ,YAAYzO,iBACjD9B,KAAKuQ,YAAYzO,cAAa,SAAI2V,EAAkBC,GAClD,OAAOD,EAAW,MAAQC,IAI1B1X,KAAKuQ,YAAYlM,UAAuC,IAA3BrE,KAAKuQ,YAAYlP,MAChD,MAAMsW,MAAM,6CAIRxI,EAAAjP,UAAAsX,uBAAR,WAAA,IAAAhL,EAAAxM,KACEA,KAAKuQ,YAAYlP,MAAQ,EACzBrB,KAAKuQ,YAAYjP,KAAOtB,KAAKuQ,YAAYvO,WAAWpB,OAAS,EAC7DZ,KAAKuQ,YAAYhP,KAAO,EAEpB8D,EAAYC,kBAAkBtF,KAAKuQ,YAAY1O,aACjD7B,KAAKuQ,YAAY1O,UAAS,SAAIsE,GAC5B,OAAIqG,EAAK+D,YAAYtO,uBACZ2V,OAAOpL,EAAKqJ,aAAa1P,IAE3ByR,OAAOzR,KAIlBnG,KAAKuQ,YAAYxO,UAAS,SAAIyE,GAE5B,OADmCgG,EAAK+D,YAAYvO,WAAWwE,GACnDuH,SAIRoB,EAAAjP,UAAAqX,sBAAR,WAUE,GATIlS,EAAYC,kBAAkBtF,KAAKuQ,YAAYhP,MACjDvB,KAAKuQ,YAAYhP,KAAO,GAExBvB,KAAKuQ,YAAYhP,MAAQvB,KAAKuQ,YAAYhP,KACtCvB,KAAKuQ,YAAYhP,MAAQ,IAC3BvB,KAAKuQ,YAAYhP,KAAO,IAIxB8D,EAAYC,kBAAkBtF,KAAKuQ,YAAYjP,OAC/C+D,EAAYC,kBAAkBtF,KAAKuQ,YAAYlP,OACjD,MAAMsW,MAAM,2CAEd3X,KAAKuQ,YAAYjP,MAAQtB,KAAKuQ,YAAYjP,KAC1CtB,KAAKuQ,YAAYlP,OAASrB,KAAKuQ,YAAYlP,MAEvCgE,EAAYC,kBAAkBtF,KAAKuQ,YAAY1O,aACjD7B,KAAKuQ,YAAY1O,UAAS,SAAIhB,GAA0B,OAAA+W,OAAO/W,MAK3DsO,EAAAjP,UAAAoX,YAAR,WACEtX,KAAKoT,sBACLpT,KAAKsT,mBACLtT,KAAKuT,kBACLvT,KAAKwT,mBACLxT,KAAKkU,eACLlU,KAAK0T,uBACL1T,KAAK2S,sBACL3S,KAAKqT,0BACLrT,KAAK6X,0BAIC1I,EAAAjP,UAAAsS,aAAR,SAAqBD,GAEfA,IAAgBtN,EAAYC,KAAOqN,IAAgBtN,EAAYE,MACjEoN,EAActN,EAAYC,KAGxBqN,IAAgBtN,EAAYC,IAC9BlF,KAAKuV,iBAAiBrI,QACblN,KAAKmT,OAASZ,IAAgBtN,EAAYE,KACnDnF,KAAKwV,iBAAiBtI,SAIlBiC,EAAAjP,UAAA2X,uBAAR,WACOxS,EAAYC,kBAAkBtF,KAAK2Q,uBACtC3Q,KAAK8X,eAAe9X,KAAK2Q,qBACc3Q,KAAKsV,kBAAkBtV,KAAK2Q,qBAC3DzD,UAKJiC,EAAAjP,UAAAkT,oBAAR,WAAA,IAAA5G,EAAAxM,KACEA,KAAK+X,cAEL/X,KAAKgY,kBAAkBzN,cAAcvK,KAAKuQ,YAAYrN,iBAAmBlD,KAAKuQ,YAAY9N,iBAC1FzC,KAAKiY,iBAAiB1N,cAAcvK,KAAKuQ,YAAYrN,iBAAmBlD,KAAKuQ,YAAY9N,qBAEnFyV,EAA8BlY,KAAKuQ,YAAYrN,kBAAoBlD,KAAKwR,kBAC9ExR,KAAKmY,sBAAsB5N,cAAc2N,GAAsBlY,KAAKuQ,YAAY/N,mBAChFxC,KAAKoY,sBAAsB7N,cAAc2N,IAAuBlY,KAAKmT,OAASnT,KAAKuQ,YAAY/N,mBAC/FxC,KAAKqY,qBAAqB9N,cAAc2N,IAAuBlY,KAAKmT,OAASnT,KAAKuQ,YAAY/N,mBAC9FxC,KAAKsY,oBAAoB/N,eAAevK,KAAKmT,QAAUnT,KAAKuQ,YAAYnO,kBACxEpC,KAAKuY,6BAA6BhO,eAAevK,KAAKmT,QAAUnT,KAAKuQ,YAAYhO,wBACjFvC,KAAKwY,8BAA8BjO,eAAevK,KAAKmT,QAAUnT,KAAKuQ,YAAYhO,wBAElFvC,KAAKqR,wBAA0BrR,KAAKmT,OAASnT,KAAKuQ,YAAYhO,uBAC9DvC,KAAKsR,2BAA6BtR,KAAKuQ,YAAYrO,iBAAmBlC,KAAKuQ,YAAYtM,gBACvFjE,KAAKuR,sBAAwBvR,KAAKwR,mBAAqBxR,KAAK2P,QAAQzM,gBAEhElD,KAAK+Q,6BAA+B/Q,KAAKuQ,YAAY/M,WACvDxD,KAAK4S,sBAILV,YAAU,WAAe1F,EAAK8K,kBAK5BtX,KAAKgR,4BAA8BhR,KAAKuQ,YAAYvL,SACtDkN,YAAU,WAAe1F,EAAKwE,0BAA4BxE,EAAK+D,YAAYvL,YAKvEmK,EAAAjP,UAAAwT,qBAAR,WACM1T,KAAKuQ,YAAY3N,UAAY5C,KAAKuQ,YAAY5N,SAChD3C,KAAKkU,eAELlU,KAAKyY,cAKDtJ,EAAAjP,UAAAyS,oBAAR,WACE3S,KAAKiR,0BAA4BjR,KAAKuQ,YAAY3N,SAAW,WAAa,MAIpEuM,EAAAjP,UAAA0S,oBAAR,mBACE5S,KAAK+Q,2BAA6B/Q,KAAKuQ,YAAY/M,aACnD,IAAsB,IAAAkV,EAAAtY,EAAAJ,KAAK2Y,wBAAsBC,EAAAF,EAAA/X,QAAAiY,EAAA9X,KAAA8X,EAAAF,EAAA/X,OAAE,CAA9C,IAAMkY,EAAOD,EAAA/X,MAEXwE,EAAYC,kBAAkBuT,IACjCA,EAAQjO,YAAY5K,KAAKuQ,YAAY/M,8GAKnC2L,EAAAjP,UAAA6X,YAAR,uBACE,IAAsB,IAAAW,EAAAtY,EAAAJ,KAAK2Y,wBAAsBC,EAAAF,EAAA/X,QAAAiY,EAAA9X,KAAA8X,EAAAF,EAAA/X,OAAE,CAAjCiY,EAAA/X,MACRgK,SAAS7K,KAAKuQ,YAAY1M,2GAI9BsL,EAAAjP,UAAAyY,qBAAR,WACE,MAAO,CAAC3Y,KAAKuY,6BACXvY,KAAKwY,8BACLxY,KAAK8Y,eACL9Y,KAAKsY,oBACLtY,KAAKuV,iBACLvV,KAAKwV,iBACLxV,KAAKgY,kBACLhY,KAAKiY,iBACLjY,KAAKmY,sBACLnY,KAAKoY,sBACLpY,KAAKqY,qBACLrY,KAAK+Y,eAMD5J,EAAAjP,UAAAuT,YAAR,WACEzT,KAAKoW,gBAAgBpW,KAAKqW,gBAAgBrW,KAAKqQ,eAM3CrQ,KAAKmT,OACPnT,KAAKsW,iBAAiBtW,KAAKqW,gBAAgBrW,KAAKsQ,gBAGlDtQ,KAAKuW,qBAEDvW,KAAKmT,OACPnT,KAAK0W,sBAGP1W,KAAKwW,oBAICrH,EAAAjP,UAAAoT,iBAAR,WACEtT,KAAKyW,uBAELzW,KAAKuV,iBAAiB5I,KAAO,UAExB3M,KAAKuQ,YAAY3M,iBAClB5D,KAAKuQ,YAAY5N,UAAY3C,KAAKuQ,YAAY3N,SAGhD5C,KAAKuV,iBAAiB3I,SAAW,GAFjC5M,KAAKuV,iBAAiB3I,SAAW,IAK/B5M,KAAKuQ,YAAY/M,WACnBxD,KAAKuV,iBAAiB1I,gBAAkB,YAGrCxH,EAAYC,kBAAkBtF,KAAKuQ,YAAY7L,WAExCW,EAAYC,kBAAkBtF,KAAKuQ,YAAY5L,kBACzD3E,KAAKuV,iBAAiB5Q,eAAiB3E,KAAKuQ,YAAY5L,gBAFxD3E,KAAKuV,iBAAiB7Q,UAAY1E,KAAKuQ,YAAY7L,UAKjD1E,KAAKmT,QACPnT,KAAKwV,iBAAiB7I,KAAO,UAEzB3M,KAAKuQ,YAAY3M,iBACjB5D,KAAKuQ,YAAY5N,UAAY3C,KAAKuQ,YAAY3N,SAGhD5C,KAAKwV,iBAAiB5I,SAAW,GAFjC5M,KAAKwV,iBAAiB5I,SAAW,IAKnC5M,KAAKwV,iBAAiB3I,gBAAkB7M,KAAKuQ,YAAY/M,SAAW,WAAa,aAE5E6B,EAAYC,kBAAkBtF,KAAKuQ,YAAY3L,eAExCS,EAAYC,kBAAkBtF,KAAKuQ,YAAY1L,sBACzD7E,KAAKwV,iBAAiB7Q,eAAiB3E,KAAKuQ,YAAY1L,oBAFxD7E,KAAKwV,iBAAiB9Q,UAAY1E,KAAKuQ,YAAY3L,gBAQjDuK,EAAAjP,UAAAuW,qBAAR,WACEzW,KAAKuV,iBAAiBzI,eAAiB9M,KAAKa,OAAOmY,WACnDhZ,KAAKuV,iBAAiBxI,cAAgB/M,KAAKuQ,YAAY1O,WAAW7B,KAAKa,MAAOE,EAAUC,KACxFhB,KAAKuV,iBAAiBvI,aAAehN,KAAKuQ,YAAYlP,MAAM2X,WAC5DhZ,KAAKuV,iBAAiBtI,aAAejN,KAAKuQ,YAAYjP,KAAK0X,WAEvDhZ,KAAKmT,QACPnT,KAAKwV,iBAAiB1I,eAAiB9M,KAAKyO,WAAWuK,WACvDhZ,KAAKwV,iBAAiBzI,cAAgB/M,KAAKuQ,YAAY1O,WAAW7B,KAAKyO,UAAW1N,EAAUE,MAC5FjB,KAAKwV,iBAAiBxI,aAAehN,KAAKuQ,YAAYlP,MAAM2X,WAC5DhZ,KAAKwV,iBAAiBvI,aAAejN,KAAKuQ,YAAYjP,KAAK0X,aAMvD7J,EAAAjP,UAAAmT,wBAAR,WACOhO,EAAYC,kBAAkBtF,KAAKuQ,YAAYzL,iBAGlD9E,KAAKuV,iBAAiBtK,qBAFtBjL,KAAKuV,iBAAiBlK,aAAarL,KAAKuQ,YAAYzL,qBAKhDmU,EAAsBjZ,KAAKuV,iBAAiBhI,UAElDvN,KAAKwQ,oBAAsByI,EAAc,EAEpC5T,EAAYC,kBAAkBtF,KAAKuQ,YAAYxL,cAGlD/E,KAAK8Y,eAAe7N,qBAFpBjL,KAAK8Y,eAAezN,aAAarL,KAAKuQ,YAAYxL,cAKpD/E,KAAKyQ,kBAAoBzQ,KAAK8Y,eAAevL,UAAY0L,EAErDjZ,KAAKgQ,aACPhQ,KAAKwT,mBACLxT,KAAKuT,kBACLvT,KAAKyT,gBAIDtE,EAAAjP,UAAAiS,wCAAR,WACEnS,KAAKqT,0BACLrT,KAAKsP,mBAAmBsE,iBAIlBzE,EAAAjP,UAAAsW,iBAAR,WAAA,IAAAhK,EAAAxM,KACE,GAAKA,KAAKuQ,YAAYtN,UAAtB,KAIMI,EAAwBgC,EAAYC,kBAAkBtF,KAAKuQ,YAAYlN,YAEzErD,KAAKkZ,gBADLlZ,KAAKuQ,YAAYlN,WAEfxB,EAAoB7B,KAAKuQ,YAAY/M,SAAW,aAAe,aAEjExD,KAAKuQ,YAAYrM,aACnBb,EAAW8V,cAGPC,EAAmB/V,EAAWgD,KAAG,SAAExF,OACnCqN,EAAmB1B,EAAK6J,gBAAgBxV,GAExC2L,EAAK+D,YAAY/M,WACnB0K,EAAW1B,EAAKiE,kBAAoBvC,OAGhCmL,EAAsBxX,EAAY,IAAM+D,KAAKoF,MAAMkD,GAAY,MAC/DoL,EAAa,IAAIC,EA4BvB,GA3BAD,EAAK7L,SAAWjB,EAAKgN,eAAe3Y,GACpCyY,EAAK5L,MAAQ,CACX+L,oBAAqBJ,EACrBK,iBAAkBL,EAClBM,eAAgBN,EAChBO,gBAAiBP,EACjBQ,UAAWR,GAETC,EAAK7L,WAAapI,EAAYC,kBAAkBkH,EAAK+D,YAAY9M,wBACnE6V,EAAK5L,MAAM,oBAAsBlB,EAAK/I,wBAEnC6V,EAAK7L,UAAapI,EAAYC,kBAAkBkH,EAAK+D,YAAY7M,gBACpE4V,EAAK5L,MAAM,oBAAsBlB,EAAK9I,aAAa7C,IAEhDwE,EAAYC,kBAAkBkH,EAAK+D,YAAYjN,gBAClDgW,EAAK3L,QAAUnB,EAAK+D,YAAYjN,aAAazC,GAC7CyY,EAAK1L,iBAAmBpB,EAAK+D,YAAY/M,SAAW,QAAU,OAE5DgJ,EAAK+D,YAAYrN,iBAAoBrC,EAAQ2L,EAAK+D,YAAYnN,eAAkB,IAClFkW,EAAKzY,MAAQ2L,EAAKsN,gBAAgBjZ,EAAOE,EAAUK,WAC9CiE,EAAYC,kBAAkBkH,EAAK+D,YAAYhN,sBAClD+V,EAAKzL,aAAerB,EAAK+D,YAAYhN,mBAAmB1C,GACxDyY,EAAKxL,sBAAwBtB,EAAK+D,YAAY/M,SAC1C,QACA,SAGH6B,EAAYC,kBAAkBkH,EAAK+D,YAAYxO,WAAY,KACxDgM,EAAiBvB,EAAK+D,YAAYxO,UAAUlB,GAC7CwE,EAAYC,kBAAkByI,KACjCuL,EAAKvL,OAASA,GAGlB,OAAOuL,KAKT,GAAKjU,EAAYC,kBAAkBtF,KAAKyR,QAAUzR,KAAKyR,MAAM7Q,SAAWwY,EAASxY,OAK/EZ,KAAKyR,MAAQ2H,OAJb,IAAK,IAAI3Y,EAAI,EAAGA,EAAK2Y,EAASxY,SAAUH,EACtCjB,OAAOkT,OAAO1S,KAAKyR,MAAMhR,GAAI2Y,EAAS3Y,IAM1CT,KAAKsP,mBAAmBsE,kBAGlBzE,EAAAjP,UAAAgZ,cAAR,WAGE,QAFM3X,EAAiB8D,EAAYC,kBAAkBtF,KAAKuQ,YAAYpN,UAAyCnD,KAAKuQ,YAAYhP,KAA7CvB,KAAKuQ,YAAYpN,SAC9FE,EAAuB,GACpBxC,EAAgBb,KAAKuQ,YAAYlP,MAAOR,GAASb,KAAKuQ,YAAYjP,KAAMT,GAASU,EACxF8B,EAAWoI,KAAK5K,GAElB,OAAOwC,GAGD8L,EAAAjP,UAAAsZ,eAAR,SAAuB3Y,GACrB,IAAKb,KAAKmT,MACR,GAAK9N,EAAYC,kBAAkBtF,KAAKuQ,YAAYjO,4BAW7C,GAAItC,KAAKuQ,YAAYlO,qBAC1B,GAAIxB,GAASb,KAAKqQ,aAChB,OAAO,OAEJ,GAAIrQ,KAAKuQ,YAAYnO,kBAAoBvB,GAASb,KAAKqQ,aAC5D,OAAO,MAhBuE,KACxE0J,EAAiB/Z,KAAKuQ,YAAYjO,0BACxC,GAAItC,KAAKqQ,aAAe0J,GACpBlZ,GAASkZ,GACTlZ,GAASb,KAAKqQ,aAChB,OAAO,EACF,GAAIrQ,KAAKqQ,aAAe0J,GACpBlZ,GAASkZ,GACTlZ,GAASb,KAAKqQ,aACvB,OAAO,EAWb,SAAIrQ,KAAKmT,OAAStS,GAASb,KAAKqQ,cAAgBxP,GAASb,KAAKsQ,gBAQxDnB,EAAAjP,UAAAsT,iBAAR,WACE,IAAKxT,KAAKgY,kBAAkBtN,WAAY,CACtC1K,KAAKgY,kBAAkB3K,SAASrN,KAAK8Z,gBAAgB9Z,KAAKuQ,YAAYlP,MAAON,EAAUG,QACvFlB,KAAKgY,kBAAkB/M,yBACjBiD,EAAmBlO,KAAKuQ,YAAYrM,YACtClE,KAAK8Y,eAAevL,UAAYvN,KAAKgY,kBAAkBzK,UACvD,EACJvN,KAAKgY,kBAAkBlN,YAAYoD,KAK/BiB,EAAAjP,UAAAqT,gBAAR,WACE,IAAKvT,KAAKiY,iBAAiBvN,WAAY,CACrC1K,KAAKiY,iBAAiB5K,SAASrN,KAAK8Z,gBAAgB9Z,KAAKuQ,YAAYjP,KAAMP,EAAUI,OACrFnB,KAAKiY,iBAAiBhN,yBAChBiD,EAAmBlO,KAAKuQ,YAAYrM,YACtC,EACAlE,KAAK8Y,eAAevL,UAAYvN,KAAKiY,iBAAiB1K,UAC1DvN,KAAKiY,iBAAiBnN,YAAYoD,KAK9BiB,EAAAjP,UAAA8Z,cAAR,SAAsBC,EAAoBC,GACpCD,IAAUhV,EAAYC,IACxBlF,KAAKoW,gBAAgB8D,GACZD,IAAUhV,EAAYE,KAC/BnF,KAAKsW,iBAAiB4D,GAGxBla,KAAKuW,qBACLvW,KAAKwW,mBACDxW,KAAKmT,OACPnT,KAAK0W,uBAKDvH,EAAAjP,UAAAia,kBAAR,SAA0BC,EAAwBF,OAC1CG,EAA0BD,IAAcnV,EAAYC,IACtDlF,KAAKmY,sBAAsB5K,UAC3BvN,KAAKoY,sBAAsB7K,UACzB+M,EAAwBJ,EAASG,EAAiB,EAAIra,KAAKwQ,oBAC3D+J,EAAsBva,KAAK8Y,eAAevL,UAAY8M,EAE5D,OAAKra,KAAKuQ,YAAYnM,mBAIjBpE,KAAKuQ,YAAYrM,aAAekW,IAAcnV,EAAYC,MAC1DlF,KAAKuQ,YAAYrM,aAAekW,IAAcnV,EAAYE,IACtDS,KAAKyB,IAAIiT,EAAeC,GAExB3U,KAAKyB,IAAIzB,KAAK0B,IAAIgT,EAAe,GAAIC,GAPrCD,GAYHnL,EAAAjP,UAAAkW,gBAAR,SAAwB8D,GACtBla,KAAKuV,iBAAiBzK,YAAYoP,GAClCla,KAAKmY,sBAAsB9K,SAASrN,KAAK8Z,gBAAgB9Z,KAAKqQ,aAActP,EAAUC,MACtFhB,KAAKmY,sBAAsBrN,YAAY9K,KAAKma,kBAAkBlV,EAAYC,IAAKgV,IAE1E7U,EAAYC,kBAAkBtF,KAAKuQ,YAAY5M,mBAClD3D,KAAKmR,gBAAkB,CACrBqJ,gBAAiBxa,KAAK2D,gBAAgBsB,EAAYC,OAIlDlF,KAAKuQ,YAAY7N,qBACnB1C,KAAKya,sCAKDtL,EAAAjP,UAAAoW,iBAAR,SAAyB4D,GACvBla,KAAKwV,iBAAiB1K,YAAYoP,GAClCla,KAAKoY,sBAAsB/K,SAASrN,KAAK8Z,gBAAgB9Z,KAAKsQ,cAAevP,EAAUE,OACvFjB,KAAKoY,sBAAsBtN,YAAY9K,KAAKma,kBAAkBlV,EAAYE,IAAK+U,IAE1E7U,EAAYC,kBAAkBtF,KAAKuQ,YAAY5M,mBAClD3D,KAAKoR,gBAAkB,CACrBoJ,gBAAiBxa,KAAK2D,gBAAgBsB,EAAYE,OAGlDnF,KAAKuQ,YAAY7N,qBACnB1C,KAAKya,sCAKDtL,EAAAjP,UAAAua,mCAAR,WAEE,IAAIza,KAAKuQ,YAAY/N,kBAArB,KAGIkY,GAAmB,EACnBC,GAAkB,EAChBC,EAA6B5a,KAAK6a,uBAAuB7a,KAAKmY,uBAC9D2C,EAA4B9a,KAAK+a,sBAAsB/a,KAAKmY,uBAC5D6C,EAA4Bhb,KAAK+a,sBAAsB/a,KAAKoY,uBAC5D6C,EAAkCjb,KAAK6a,uBAAuB7a,KAAKqY,sBACnE6C,EAAiClb,KAAK+a,sBAAsB/a,KAAKqY,sBAkBvE,GAhBIuC,GACFF,GAAmB,EACnB1a,KAAKgY,kBAAkBxN,SAEvBkQ,GAAmB,EACnB1a,KAAKgY,kBAAkBvN,QAGrBqQ,GACFH,GAAkB,EAClB3a,KAAKiY,iBAAiBzN,SAEtBmQ,GAAkB,EAClB3a,KAAKiY,iBAAiBxN,QAGpBzK,KAAKmT,MAAO,KACRgI,EAAoBnb,KAAKqY,qBAAqB1N,YAAcuQ,EAAwBF,EACpFI,EAAqBpb,KAAKqY,qBAAqB1N,YAAcsQ,EAAyBL,EAExFO,EACFnb,KAAKiY,iBAAiBzN,OACZmQ,GACV3a,KAAKiY,iBAAiBxN,OAIpB2Q,EACFpb,KAAKgY,kBAAkBxN,OACbkQ,GACV1a,KAAKgY,kBAAkBvN,UAKrB0E,EAAAjP,UAAA2a,uBAAR,SAA+BQ,OACvBtQ,EAAcsQ,EAAMnN,SACpB5C,EAAc+P,EAAM9N,UACpB+N,EAAmBtb,KAAKgY,kBAAkB9J,SAC1CqN,EAAmBvb,KAAKgY,kBAAkBzK,UAChD,OAAOvN,KAAKuQ,YAAYrM,YACpB6G,EAAMO,GAAOgQ,EAAW,EACxBvQ,GAAOuQ,EAAWC,EAAW,GAG3BpM,EAAAjP,UAAA6a,sBAAR,SAA8BM,OACtBtQ,EAAcsQ,EAAMnN,SACpB5C,EAAc+P,EAAM9N,UACpBiO,EAAkBxb,KAAKiY,iBAAiB/J,SACxCuN,EAAkBzb,KAAKiY,iBAAiB1K,UAC9C,OAAOvN,KAAKuQ,YAAYrM,YACpB6G,GAAOyQ,EAAUC,EAAU,EAC3B1Q,EAAMO,GAAOkQ,EAAU,GAIrBrM,EAAAjP,UAAAqW,mBAAR,eACMrI,EAAW,EACXX,EAAY,EACVmO,EAAmC1b,KAAKuQ,YAAYrM,aACnDlE,KAAKuQ,YAAYlO,oBAClBrC,KAAKuQ,YAAYlO,oBACjBsZ,EAA2B3b,KAAKuQ,YAAYrM,YAC5ClE,KAAKwV,iBAAiBtH,SAAWlO,KAAKwQ,oBACtCxQ,KAAKuV,iBAAiBrH,SAAWlO,KAAKwQ,oBAE5C,GAAIxQ,KAAKmT,MACP5F,EAAY3H,KAAKU,IAAItG,KAAKwV,iBAAiBtH,SAAWlO,KAAKuV,iBAAiBrH,UAC5EA,EAAWyN,OAEX,GAAKtW,EAAYC,kBAAkBtF,KAAKuQ,YAAYjO,2BAazCoZ,GACTnO,EAAY3H,KAAKtE,KAAKsE,KAAKU,IAAItG,KAAKyQ,kBAAoBzQ,KAAKuV,iBAAiBrH,UAAYlO,KAAKwQ,qBAC/FtC,EAAWtI,KAAKvE,MAAMrB,KAAKuV,iBAAiBrH,SAAWlO,KAAKwQ,uBAE5DjD,EAAYvN,KAAKuV,iBAAiBrH,SAAWlO,KAAKwQ,oBAClDtC,EAAW,OAlBmE,KACxE6L,EAAiB/Z,KAAKuQ,YAAYjO,0BAClCsZ,EAAyB5b,KAAKqW,gBAAgB0D,IACV/Z,KAAKuQ,YAAYrM,YACrDlE,KAAKqQ,cAAgB0J,EACrB/Z,KAAKqQ,aAAe0J,IAExBxM,EAAYvN,KAAKuV,iBAAiBrH,SAAW0N,EAC7C1N,EAAW0N,EAAiB5b,KAAKwQ,sBAEjCjD,EAAYqO,EAAiB5b,KAAKuV,iBAAiBrH,SACnDA,EAAWlO,KAAKuV,iBAAiBrH,SAAWlO,KAAKwQ,qBA2BvD,GAjBAxQ,KAAKsY,oBAAoBjN,aAAakC,GACtCvN,KAAKsY,oBAAoBxN,YAAYoD,GACjClO,KAAKmT,OAASnT,KAAKuQ,YAAYhO,yBAC7BvC,KAAKuQ,YAAYrM,aACnBlE,KAAKwY,8BAA8BnN,aAAa6C,GAChDlO,KAAKwY,8BAA8B1N,YAAY,GAC/C9K,KAAK8Y,eAAe7N,qBACpBjL,KAAKuY,6BAA6BlN,aAAarL,KAAK8Y,eAAevL,WAAaW,EAAWX,IAC3FvN,KAAKuY,6BAA6BzN,YAAYoD,EAAWX,KAEzDvN,KAAKuY,6BAA6BlN,aAAa6C,GAC/ClO,KAAKuY,6BAA6BzN,YAAY,GAC9C9K,KAAK8Y,eAAe7N,qBACpBjL,KAAKwY,8BAA8BnN,aAAarL,KAAK8Y,eAAevL,WAAaW,EAAWX,IAC5FvN,KAAKwY,8BAA8B1N,YAAYoD,EAAWX,KAGzDlI,EAAYC,kBAAkBtF,KAAKuQ,YAAY9M,uBAK7C,IAAK4B,EAAYC,kBAAkBtF,KAAKuQ,YAAY9L,sBAAuB,KAC1EoX,EAAmBxW,EAAYC,kBAAkBtF,KAAKuQ,YAAYjO,2BAEhE,EADAtC,KAAKqW,gBAAgBrW,KAAKuQ,YAAYjO,2BAExCwZ,EAAqBD,EAAS3N,EAAW,IAAMwN,GAA6BG,EAAS3N,GAAY,GAAKwN,EACtGK,EAAoB/b,KAAKuQ,YAAY/M,SACrCsY,EAAW,SAAW,MACtBA,EAAW,OAAS,QAC1B9b,KAAKkR,SAAW,CACd8K,gBACE,sBACAD,EACA,KACA/b,KAAKuQ,YAAY9L,qBAAqBwX,KACtC,OACAjc,KAAKuQ,YAAY9L,qBAAqByX,GACtC,UAEAlc,KAAKuQ,YAAY/M,UACnBxD,KAAKkR,SAASiL,mBACZ,WACCN,EACCtO,EACAW,GACC4N,GAAY9b,KAAKwQ,oBAAsB,IAC1C,KACFxQ,KAAKkR,SAASkL,eACZ,SAAWpc,KAAK8Y,eAAevL,UAAYvN,KAAKwQ,qBAAuB,OAEzExQ,KAAKkR,SAASiL,mBACZN,EACA3N,GACC4N,EAAW9b,KAAKwQ,oBAAsB,GACvC,YACFxQ,KAAKkR,SAASkL,eACZpc,KAAK8Y,eAAevL,UAAYvN,KAAKwQ,oBAAsB,gBAxCU,KACnE6L,EAAgBrc,KAAKyD,uBAC3BzD,KAAKkR,SAAW,CACdsJ,gBAAiB6B,KA2CflN,EAAAjP,UAAAuD,qBAAR,WACE,OAAIzD,KAAKmT,MACAnT,KAAKuQ,YAAY9M,qBACtBzD,KAAKa,MACLb,KAAKyO,WAGFzO,KAAKuQ,YAAY9M,qBAAqBzD,KAAKa,QAI5CsO,EAAAjP,UAAAyD,gBAAR,SAAwB4O,GACtB,OAAIA,IAAgBtN,EAAYE,IACvBnF,KAAKuQ,YAAY5M,gBACtB3D,KAAKyO,UACL8D,GAGGvS,KAAKuQ,YAAY5M,gBACtB3D,KAAKa,MACL0R,IAKIpD,EAAAjP,UAAAwD,aAAR,SAAqB7C,GACnB,OAAOb,KAAKuQ,YAAY7M,aAAa7C,IAI/BsO,EAAAjP,UAAAwW,oBAAR,WAUE,GARI1W,KAAKuQ,YAAYrM,YAEjBlE,KAAKmY,sBAAsBjK,SAAWlO,KAAKmY,sBAAsB5K,UAAY,IAAMvN,KAAKoY,sBAAsBlK,SAG9GlO,KAAKmY,sBAAsBjK,SAAWlO,KAAKmY,sBAAsB5K,UAAY,IAAMvN,KAAKoY,sBAAsBlK,SAG9F,KACZoO,EAA0Btc,KAAK8Z,gBAAgB9Z,KAAKqQ,aAActP,EAAUC,KAC5Eub,EAA2Bvc,KAAK8Z,gBAAgB9Z,KAAKsQ,cAAevP,EAAUE,MAC9Eub,EAA6Bxc,KAAKuQ,YAAYrM,YAChDlE,KAAKuQ,YAAYzO,cAAcya,EAAkBD,GACjDtc,KAAKuQ,YAAYzO,cAAcwa,EAAiBC,GAEpDvc,KAAKqY,qBAAqBhL,SAASmP,OAC7BzR,EAAc/K,KAAKuQ,YAAYnM,mBACjCwB,KAAKyB,IACHzB,KAAK0B,IACHtH,KAAKsY,oBAAoBpK,SACvBlO,KAAKsY,oBAAoB/K,UAAY,EACrCvN,KAAKqY,qBAAqB9K,UAAY,EACxC,GAEFvN,KAAK8Y,eAAevL,UAAYvN,KAAKqY,qBAAqB9K,WAE5DvN,KAAKsY,oBAAoBpK,SAAWlO,KAAKsY,oBAAoB/K,UAAY,EAAIvN,KAAKqY,qBAAqB9K,UAAY,EAEvHvN,KAAKqY,qBAAqBvN,YAAYC,GACtC/K,KAAKmY,sBAAsB3N,OAC3BxK,KAAKoY,sBAAsB5N,OAC3BxK,KAAKqY,qBAAqB5N,YAE1BzK,KAAKsW,iBAAiBtW,KAAKqW,gBAAgBrW,KAAKsQ,gBAChDtQ,KAAKoW,gBAAgBpW,KAAKqW,gBAAgBrW,KAAKqQ,eAC/CrQ,KAAKoY,sBAAsB3N,OAC3BzK,KAAKmY,sBAAsB1N,OAC3BzK,KAAKqY,qBAAqB7N,OAExBxK,KAAKuQ,YAAY7N,qBACnB1C,KAAKya,sCAKDtL,EAAAjP,UAAA4Z,gBAAR,SAAwBjZ,EAAeoZ,GAIrC,OAHK5U,EAAYC,kBAAkBtF,KAAKuQ,YAAYvO,aAAgBhC,KAAKuQ,YAAYtO,yBACnFpB,EAAQb,KAAK6V,aAAahV,IAErBb,KAAKuQ,YAAY1O,UAAUhB,EAAOoZ,IAInC9K,EAAAjP,UAAA8W,UAAR,SAAkBnW,EAAe4b,OACzBlb,EAAgB8D,EAAYC,kBAAkBmX,GAA2Bzc,KAAKuQ,YAAYhP,KAA9Bkb,EAC9DC,EAA4BzV,EAAWC,uBACxCrG,EAAQb,KAAKuQ,YAAYlP,OAASE,EAAMvB,KAAKuQ,YAAY/L,gBAE5D,OADAkY,EAAoB9W,KAAKoF,MAAM0R,GAAqBnb,EAC7C0F,EAAWC,sBAAsBlH,KAAKuQ,YAAYlP,MAAQqb,EAAmB1c,KAAKuQ,YAAY/L,iBAI/F2K,EAAAjP,UAAAmW,gBAAR,SAAwB7Q,OAClBmX,EAA+BtX,EAAYE,sBAC1CF,EAAYC,kBAAkBtF,KAAKuQ,YAAYjM,uBAEzCtE,KAAKuQ,YAAYlM,WAC1BsY,EAAKtX,EAAYM,oBAFjBgX,EAAK3c,KAAKuQ,YAAYjM,0BAMpByB,EAAkB4W,EADtBnX,EAAMyB,EAAWG,aAAa5B,EAAKxF,KAAKuQ,YAAYlP,MAAOrB,KAAKuQ,YAAYjP,MAC9CtB,KAAKuQ,YAAYlP,MAAOrB,KAAKuQ,YAAYjP,MAOvE,OANI+D,EAAYC,kBAAkBS,KAChCA,EAAU,GAER/F,KAAKuQ,YAAYrM,cACnB6B,EAAU,EAAIA,GAETA,EAAU/F,KAAKyQ,mBAIhBtB,EAAAjP,UAAA0c,gBAAR,SAAwB1O,OAClBnI,EAAkBmI,EAAWlO,KAAKyQ,kBAClCzQ,KAAKuQ,YAAYrM,cACnB6B,EAAU,EAAIA,OAEZ4W,EAA8BtX,EAAYS,sBACzCT,EAAYC,kBAAkBtF,KAAKuQ,YAAYhM,uBAEzCvE,KAAKuQ,YAAYlM,WAC1BsY,EAAKtX,EAAYW,oBAFjB2W,EAAK3c,KAAKuQ,YAAYhM,0BAIlB1D,EAAgB8b,EAAG5W,EAAS/F,KAAKuQ,YAAYlP,MAAOrB,KAAKuQ,YAAYjP,MAC3E,OAAQ+D,EAAYC,kBAAkBzE,GAAiB,EAARA,GAIzCsO,EAAAjP,UAAA2c,WAAR,SAAmBlW,EAA8BmW,GAC/C,GAAInW,aAAiBoW,WACnB,OAAO/c,KAAKuQ,YAAY/M,SAAWmD,EAAMqW,QAAUrW,EAAMsW,YAGvDC,EAAa,EACXpW,EAAqBH,EAAMG,QACjC,IAAKzB,EAAYC,kBAAkBwX,GACjC,IAAK,IAAIrc,EAAI,EAAGA,EAAIqG,EAAQlG,OAAQH,IAClC,GAAIqG,EAAQrG,GAAG0c,aAAeL,EAAe,CAC3CI,EAAazc,EACb,MAON,OAAOT,KAAKuQ,YAAY/M,SAAWsD,EAAQoW,GAAYF,QAAUlW,EAAQoW,GAAYD,SAI/E9N,EAAAjP,UAAAkd,iBAAR,SAAyBzW,EAA8BmW,OAC/CO,EAAwCrd,KAAKqP,WAAWtH,cAAcmD,wBAEtEoS,EAAoBtd,KAAKuQ,YAAY/M,SACzC6Z,EAA0BpT,OAASoT,EAA0BrT,KAO/D,OALIhK,KAAKuQ,YAAY/M,UACPxD,KAAK6c,WAAWlW,EAAOmW,GAAiBQ,EAEzCtd,KAAK6c,WAAWlW,EAAOmW,GAAiBQ,GAEnCtd,KAAKuQ,YAAY1M,MAAQ7D,KAAKwQ,qBAI1CrB,EAAAjP,UAAAqd,iBAAR,SAAyB5W,GACvB,IAAK3G,KAAKmT,MACR,OAAOlO,EAAYC,QAGfgJ,EAAmBlO,KAAKod,iBAAiBzW,GACzC6W,EAAsB5X,KAAKU,IAAI4H,EAAWlO,KAAKuV,iBAAiBrH,UAChEuP,EAAsB7X,KAAKU,IAAI4H,EAAWlO,KAAKwV,iBAAiBtH,UAEtE,OAAIsP,EAAcC,EACTxY,EAAYC,IACVsY,EAAcC,EAChBxY,EAAYE,IACTnF,KAAKuQ,YAAYrM,YAKtBgK,EAAWlO,KAAKuV,iBAAiBrH,SAAWjJ,EAAYC,IAAMD,EAAYE,IAHxE+I,EAAWlO,KAAKuV,iBAAiBrH,SAAWjJ,EAAYC,IAAMD,EAAYE,KAO7EgK,EAAAjP,UAAAuY,WAAR,WAAA,IAAAjM,EAAAxM,KACQkC,EAA0BlC,KAAKuQ,YAAYrO,eAE5ClC,KAAKuQ,YAAYtM,iBACpBjE,KAAKsY,oBAAoB/M,GAAG,aAAW,SACpC5E,GAA4B,OAAA6F,EAAKkR,WAAW,KAAMxb,EAAgByE,GAAO,GAAM,GAAM,MAItF3G,KAAKuQ,YAAYpO,oBACnBnC,KAAKuV,iBAAiBhK,GAAG,aAAW,SACjC5E,GAA4B,OAAA6F,EAAKkR,WAAWzY,EAAYC,IAAKhD,EAAgByE,GAAO,GAAM,MAE7F3G,KAAKwV,iBAAiBjK,GAAG,aAAW,SACjC5E,GAA4B,OAAA6F,EAAKkR,WAAWzY,EAAYE,IAAKjD,EAAgByE,GAAO,GAAM,QAG7F3G,KAAKuV,iBAAiBhK,GAAG,aAAW,SACjC5E,GAA4B,OAAA6F,EAAKmR,QAAQ1Y,EAAYC,IAAKyB,GAAO,GAAM,MAGtE3G,KAAKmT,OACPnT,KAAKwV,iBAAiBjK,GAAG,aAAW,SACjC5E,GAA4B,OAAA6F,EAAKmR,QAAQ1Y,EAAYE,IAAKwB,GAAO,GAAM,MAGvE3G,KAAKuQ,YAAYtM,kBACpBjE,KAAK8Y,eAAevN,GAAG,aAAW,SAC/B5E,GAA4B,OAAA6F,EAAKmR,QAAQ,KAAMhX,GAAO,GAAM,GAAM,MAErE3G,KAAK+Y,aAAaxN,GAAG,aAAW,SAC7B5E,GAA4B,OAAA6F,EAAKmR,QAAQ,KAAMhX,GAAO,GAAM,GAAM,GAAM,QAK1E3G,KAAKuQ,YAAYtM,iBACpBjE,KAAKsY,oBAAoB5M,UAAU,cAAY,SAC5C/E,GAA4B,OAAA6F,EAAKkR,WAAW,KAAMxb,EAAgByE,GAAO,GAAM,GAAM,MAGtF3G,KAAKuQ,YAAYpO,oBACnBnC,KAAKuV,iBAAiB7J,UAAU,cAAY,SACzC/E,GAA4B,OAAA6F,EAAKkR,WAAWzY,EAAYC,IAAKhD,EAAgByE,GAAO,GAAM,MAE7F3G,KAAKwV,iBAAiB9J,UAAU,cAAY,SACzC/E,GAA4B,OAAA6F,EAAKkR,WAAWzY,EAAYE,IAAKjD,EAAgByE,GAAO,GAAM,QAG7F3G,KAAKuV,iBAAiB7J,UAAU,cAAY,SACzC/E,GAA4B,OAAA6F,EAAKmR,QAAQ1Y,EAAYC,IAAKyB,GAAO,GAAM,MAEtE3G,KAAKmT,OACPnT,KAAKwV,iBAAiB9J,UAAU,cAAY,SACzC/E,GAA4B,OAAA6F,EAAKmR,QAAQ1Y,EAAYE,IAAKwB,GAAO,GAAM,MAGvE3G,KAAKuQ,YAAYtM,kBACpBjE,KAAK8Y,eAAepN,UAAU,cAAY,SACvC/E,GAA4B,OAAA6F,EAAKmR,QAAQ,KAAMhX,GAAO,GAAM,GAAM,MAErE3G,KAAK+Y,aAAarN,UAAU,cAAY,SACrC/E,GAA4B,OAAA6F,EAAKmR,QAAQ,KAAMhX,GAAO,GAAO,GAAO,GAAM,QAK7E3G,KAAKuQ,YAAY3M,kBACnB5D,KAAKuV,iBAAiBhK,GAAG,SAAO,WAAc,OAAAiB,EAAKsL,eAAe7S,EAAYC,QAC1ElF,KAAKmT,OACPnT,KAAKwV,iBAAiBjK,GAAG,SAAO,WAAc,OAAAiB,EAAKsL,eAAe7S,EAAYE,UAM5EgK,EAAAjP,UAAAgU,aAAR,mBACElU,KAAKoV,oBACLpV,KAAKqV,uBAEL,IAAsB,IAAAqD,EAAAtY,EAAAJ,KAAK2Y,wBAAsBC,EAAAF,EAAA/X,QAAAiY,EAAA9X,KAAA8X,EAAAF,EAAA/X,OAAE,CAAjCiY,EAAA/X,MACR8K,0GAIJwD,EAAAjP,UAAAwd,WAAR,SAAmBnL,EAA0BrQ,EAAyByE,EACnDiX,EAAmBC,EAAkBC,EAAiCC,GACnF7b,EACFlC,KAAKge,YAAYzL,EAAa5L,EAAOiX,EAAUC,GAE/C7d,KAAK2d,QAAQpL,EAAa5L,EAAOiX,EAAUC,EAASC,EAAuBC,IAKvE5O,EAAAjP,UAAAyd,QAAR,SAAgBpL,EAA0B5L,EAC1BiX,EAAmBC,EAAkBC,EAAiCC,GADtF,IAAAvR,EAAAxM,KAEE2G,EAAMsX,kBAEDxX,EAAoBC,aAAaC,IAAWuB,EAAoBC,YACnExB,EAAMuX,iBAKRle,KAAKqT,0BAEDhO,EAAYC,kBAAkBiN,KAChCA,EAAcvS,KAAKud,iBAAiB5W,IAGtC3G,KAAK0Q,uBAAyB6B,MAExB4L,EAAwCne,KAAKsV,kBAAkB/C,GAOrE,GANA4L,EAAezR,QAAS,EAEpB1M,KAAKuQ,YAAY3M,iBACnBua,EAAejR,QAGb0Q,EAAU,CACZ5d,KAAKoV,wBAECgJ,EAAc,SACjBC,GAAmC,OAAA7R,EAAKsE,SAASpE,OAASF,EAAK8R,WAAWD,GAAK7R,EAAK+R,OAAOF,IAE1F5X,EAAoBC,aAAaC,GACnC3G,KAAK0R,oBAAsB1R,KAAKqK,oBAAoBvC,2BAClD0W,SAAU,YAAaJ,EAAgBpe,KAAKuQ,YAAYzN,qBAE1D9C,KAAK0R,oBAAsB1R,KAAKqK,oBAAoBjC,oBAClDoW,SAAU,YAAaJ,EAAgBpe,KAAKuQ,YAAY1N,qBAI9D,GAAIgb,EAAS,CACX7d,KAAKqV,uBAECoJ,EAAa,SAChBJ,GAAmC,OAAA7R,EAAKkS,MAAML,IAE7C5X,EAAoBC,aAAaC,GACnC3G,KAAK2R,mBAAqB3R,KAAKqK,oBAAoBvC,2BAA2B0W,SAAU,WAAYC,GAEpGze,KAAK2R,mBAAqB3R,KAAKqK,oBAAoBjC,oBAAoBoW,SAAU,UAAWC,GAIhGze,KAAK6P,gBAAgB+G,KAAK5W,KAAK6W,oBAE3BpQ,EAAoBC,aAAaC,KAAWtB,EAAYC,kBAAkB,EAAsBqZ,iBAE9FtZ,EAAYC,kBAAkBtF,KAAK6Q,WACrC7Q,KAAK6Q,QAAU,EAAsB8N,eAAe,GAAGxB,YAOvDW,GACF9d,KAAKue,OAAO5X,GAAO,GAGjBoX,GACF/d,KAAK0e,MAAM/X,IAKPwI,EAAAjP,UAAAqe,OAAR,SAAe5X,EAA8BiY,OACvCC,EAA4B,KAEhC,GAAIpY,EAAoBC,aAAaC,GAAQ,CAG3C,QAFMgY,EAA4B,EAAsBA,eAE/Cle,EAAI,EAAGA,EAAIke,EAAe/d,OAAQH,IACzC,GAAIke,EAAele,GAAG0c,aAAend,KAAK6Q,QAAS,CACjDgO,EAAqBF,EAAele,GACpC,MAIJ,GAAI4E,EAAYC,kBAAkBuZ,GAChC,WAOAC,EAHE5E,EAAkB7U,EAAYC,kBAAkBuZ,GAElD7e,KAAKod,iBAAiBzW,GADtB3G,KAAKod,iBAAiBzW,EAAOkY,EAAmB1B,YAG9C4B,EAAoB/e,KAAKuQ,YAAYrM,YACrClE,KAAKuQ,YAAYlP,MACjBrB,KAAKuQ,YAAYjP,KACjB0d,EAAqBhf,KAAKuQ,YAAYrM,YAAclE,KAAKuQ,YAAYjP,KAAOtB,KAAKuQ,YAAYlP,MAE/F6Y,GAAU,EACZ4E,EAAWE,EACF9E,GAAUla,KAAKyQ,kBACxBqO,EAAWC,GAEXD,EAAW9e,KAAK4c,gBAAgB1C,GAE9B4E,EADEF,IAAavZ,EAAYC,kBAAkBtF,KAAKuQ,YAAYpN,UACnDnD,KAAKgX,UAAU8H,EAAU9e,KAAKuQ,YAAYpN,UAE1CnD,KAAKgX,UAAU8H,IAG9B9e,KAAKif,uBAAuBH,IAGtB3P,EAAAjP,UAAAwe,MAAR,SAAc/X,GACZ,GAAIF,EAAoBC,aAAaC,IACD,EAAsBgY,eACrC,GAAGxB,aAAend,KAAK6Q,QACxC,OAIJ7Q,KAAK6Q,QAAU,KAEV7Q,KAAKuQ,YAAY3M,kBACpB5D,KAAKuV,iBAAiB7I,QAAS,EAC/B1M,KAAKwV,iBAAiB9I,QAAS,EAC/B1M,KAAK0Q,uBAAyB,MAEhC1Q,KAAK8Q,SAASpE,QAAS,EAEvB1M,KAAKoV,oBACLpV,KAAKqV,mBAELrV,KAAK+P,cAAc6G,KAAK5W,KAAK6W,qBAGvB1H,EAAAjP,UAAA4X,eAAR,SAAuBvF,GAAvB,IAAA/F,EAAAxM,KACQme,EAAwCne,KAAKsV,kBAAkB/C,GACrE4L,EAAe5S,GAAG,QAAM,WAAc,OAAAiB,EAAK0S,cAAcf,MACzDA,EAAe5S,GAAG,WAAS,SAAG5E,GAA+B,OAAA6F,EAAK2S,gBAAgBxY,MAClFwX,EAAe5S,GAAG,SAAO,WAAc,OAAAiB,EAAK4S,aAC5CjB,EAAezR,QAAS,EAExB1M,KAAK0Q,uBAAyB6B,EAC9BvS,KAAK2Q,oBAAsB4B,EAC3BvS,KAAK4Q,cAAe,GAGdzB,EAAAjP,UAAAkf,QAAR,WACEpf,KAAK4Q,cAAe,EACpB5Q,KAAK+P,cAAc6G,KAAK5W,KAAK6W,qBAGvB1H,EAAAjP,UAAAgf,cAAR,SAAsBG,GACpBA,EAAQ1T,IAAI,QACZ0T,EAAQ1T,IAAI,WACZ0T,EAAQ1T,IAAI,SACZ0T,EAAQ3S,QAAS,EACbrH,EAAYC,kBAAkBtF,KAAK6Q,WACrC7Q,KAAK0Q,uBAAyB,KAC9B1Q,KAAK2Q,oBAAsB,OAIvBxB,EAAAjP,UAAAof,cAAR,SAAsBC,OACdC,EAAqBxf,KAAKuQ,YAAYjP,KAAOtB,KAAKuQ,YAAYlP,MAEhEoe,EAAuBF,EAAevf,KAAKuQ,YAAYhP,KACvDme,EAAuBH,EAAevf,KAAKuQ,YAAYhP,KACvDoe,EAAuBJ,EAAeC,EAAa,GACnDI,EAAuBL,EAAeC,EAAa,GAEnDxf,KAAKuQ,YAAYpM,mBACnBsb,EAAeF,EAAevf,KAAKuQ,YAAYhP,KAC/Cme,EAAeH,EAAevf,KAAKuQ,YAAYhP,KAC/Coe,EAAeJ,EAAeC,EAAa,GAC3CI,EAAeL,EAAeC,EAAa,QAIvCK,EAAmC,CACvCC,GAAIL,EACJM,KAAML,EACNM,KAAMN,EACNO,MAAOR,EACPS,OAAQP,EACRQ,SAAUP,EACVQ,KAAMpgB,KAAKuQ,YAAYpM,iBAAmBnE,KAAKuQ,YAAYjP,KAAOtB,KAAKuQ,YAAYlP,MACnFgf,IAAKrgB,KAAKuQ,YAAYpM,iBAAmBnE,KAAKuQ,YAAYlP,MAAQrB,KAAKuQ,YAAYjP,MAYrF,OATItB,KAAKuQ,YAAYrM,cACnB2b,EAAQG,KAAOP,EACfI,EAAQI,MAAQP,EAEZ1f,KAAKuQ,YAAY/M,WACnBqc,EAAQC,GAAKJ,EACbG,EAAQE,KAAON,IAGZI,GAGD1Q,EAAAjP,UAAAif,gBAAR,SAAwBxY,OAChB4Y,EAAuBvf,KAAKyV,0BAC5B6K,EAAmBjb,EAAYC,kBAAkBqB,EAAM2Z,SAEzD3Z,EAAMsT,MADNtT,EAAM2Z,QAcJC,EAFmCvgB,KAAKsf,cAAcC,GAVlB,CACtCiB,GAAI,KACJC,GAAI,OACJC,GAAI,OACJC,GAAI,QACJC,GAAI,SACJC,GAAI,WACJC,GAAI,OACJC,GAAI,OAGiBT,IAGzB,IAAIjb,EAAYC,kBAAkBib,KAAWlb,EAAYC,kBAAkBtF,KAAK0Q,wBAAhF,CAGA/J,EAAMuX,iBAEFle,KAAK4Q,eACP5Q,KAAK4Q,cAAe,EACpB5Q,KAAK6P,gBAAgB+G,KAAK5W,KAAK6W,yBAG3BmK,EAAsB/Z,EAAWG,aAAamZ,EAAQvgB,KAAKuQ,YAAYlP,MAAOrB,KAAKuQ,YAAYjP,MAC/Fwd,EAAmB9e,KAAKgX,UAAUgK,GACxC,GAAKhhB,KAAKuQ,YAAYpO,mBAEf,KACC8L,EAAqBjO,KAAKsQ,cAAgBtQ,KAAKqQ,aACjD4Q,OAAW,EACXC,OAAW,EAEXlhB,KAAK0Q,yBAA2BzL,EAAYC,KAC9C+b,EAAcnC,GACdoC,EAAcpC,EAAW7Q,GACPjO,KAAKuQ,YAAYjP,OAEjC2f,GADAC,EAAclhB,KAAKuQ,YAAYjP,MACH2M,IAErBjO,KAAK0Q,yBAA2BzL,EAAYE,MACrD+b,EAAcpC,GACdmC,EAAcnC,EAAW7Q,GACPjO,KAAKuQ,YAAYlP,QAEjC6f,GADAD,EAAcjhB,KAAKuQ,YAAYlP,OACH4M,IAGhCjO,KAAKmhB,oBAAoBF,EAAaC,QArBtClhB,KAAKif,uBAAuBH,KA0BxB3P,EAAAjP,UAAA8d,YAAR,SAAoBzL,EAA0B5L,EAC1BiX,EAAmBC,OAC/B3P,EAAmBlO,KAAKod,iBAAiBzW,GAE/C3G,KAAK8Q,SAAW,IAAI9C,EACpBhO,KAAK8Q,SAASpE,QAAS,EACvB1M,KAAK8Q,SAASjQ,MAAQb,KAAK4c,gBAAgB1O,GAC3ClO,KAAK8Q,SAAS7C,WAAajO,KAAKsQ,cAAgBtQ,KAAKqQ,aACrDrQ,KAAK8Q,SAAS3C,SAAWnO,KAAKuQ,YAAYrM,YACpClE,KAAKuV,iBAAiBrH,SAAWA,EACjCA,EAAWlO,KAAKuV,iBAAiBrH,SACvClO,KAAK8Q,SAAS1C,UAAYpO,KAAKuQ,YAAYrM,YACrCgK,EAAWlO,KAAKwV,iBAAiBtH,SACjClO,KAAKwV,iBAAiBtH,SAAWA,EAEvClO,KAAK2d,QAAQpL,EAAa5L,EAAOiX,EAAUC,IAIrC1O,EAAAjP,UAAAkhB,YAAR,SAAoBlH,EAAgBmH,EAAsBC,OAClDC,EAAiBvhB,KAAKuQ,YAAYrM,YACpCrD,EAAgB,KAiBpB,OAbIA,EAFAwgB,EACEC,EACMC,EACJvhB,KAAKuQ,YAAYlP,MACjBrB,KAAKuQ,YAAYjP,KAAOtB,KAAK8Q,SAAS7C,WAElCsT,EACJvhB,KAAKuQ,YAAYjP,KAAOtB,KAAK8Q,SAAS7C,WACtCjO,KAAKuQ,YAAYlP,MAGfkgB,EACJvhB,KAAK4c,gBAAgB1C,EAASla,KAAK8Q,SAAS3C,UAC5CnO,KAAK4c,gBAAgB1C,EAASla,KAAK8Q,SAAS3C,UAE3CnO,KAAKgX,UAAUnW,IAIhBsO,EAAAjP,UAAAshB,YAAR,SAAoBtH,EAAgBmH,EAAsBC,OAClDC,EAAiBvhB,KAAKuQ,YAAYrM,YACpCrD,EAAgB,KAwBpB,OApBIA,EAFAwgB,EACEC,EACMC,EACJvhB,KAAKuQ,YAAYlP,MAAQrB,KAAK8Q,SAAS7C,WACvCjO,KAAKuQ,YAAYjP,KAEbigB,EACJvhB,KAAKuQ,YAAYjP,KACjBtB,KAAKuQ,YAAYlP,MAAQrB,KAAK8Q,SAAS7C,WAGzCsT,EAEAvhB,KAAK4c,gBAAgB1C,EAASla,KAAK8Q,SAAS3C,UAC5CnO,KAAK8Q,SAAS7C,WAGdjO,KAAK4c,gBAAgB1C,EAASla,KAAK8Q,SAAS3C,UAC5CnO,KAAK8Q,SAAS7C,WAIbjO,KAAKgX,UAAUnW,IAGhBsO,EAAAjP,UAAAoe,WAAR,SAAmB3X,OAGb8a,EACAC,EACAC,EACAC,EALE1H,EAAiBla,KAAKod,iBAAiBzW,GAMzC3G,KAAKuQ,YAAYrM,aACnBud,EAAYzhB,KAAK8Q,SAAS3C,SAC1BuT,EAAa1hB,KAAK8Q,SAAS1C,UAC3BuT,EAAqB3hB,KAAKwV,iBAC1BoM,EAAoB5hB,KAAKuV,mBAEzBkM,EAAYzhB,KAAK8Q,SAAS1C,UAC1BsT,EAAa1hB,KAAK8Q,SAAS3C,SAC3BwT,EAAqB3hB,KAAKuV,iBAC1BqM,EAAoB5hB,KAAKwV,sBAMvByL,EACAC,EAJEW,EAA8B3H,GAAUwH,EACxCI,EAA4B5H,GAAUla,KAAKyQ,kBAAoBgR,EAIrE,GAAII,EAAmB,CACrB,GAAoC,IAAhCF,EAAmBzT,SACrB,OAEF+S,EAAcjhB,KAAKohB,YAAYlH,GAAQ,GAAM,GAC7CgH,EAAclhB,KAAKwhB,YAAYtH,GAAQ,GAAM,QACxC,GAAI4H,EAAiB,CAC1B,GAAIF,EAAkB1T,WAAalO,KAAKyQ,kBACtC,OAEFyQ,EAAclhB,KAAKwhB,YAAYtH,GAAQ,GAAM,GAC7C+G,EAAcjhB,KAAKohB,YAAYlH,GAAQ,GAAM,QAE7C+G,EAAcjhB,KAAKohB,YAAYlH,GAAQ,GAAO,GAC9CgH,EAAclhB,KAAKwhB,YAAYtH,GAAQ,GAAO,GAGhDla,KAAKmhB,oBAAoBF,EAAaC,IAIhC/R,EAAAjP,UAAAihB,oBAAR,SAA4BF,EAAqBC,IAC1C7b,EAAYC,kBAAkBtF,KAAKuQ,YAAY5O,WAChDsf,EAAcjhB,KAAKuQ,YAAY5O,WACjCsf,EAAcjhB,KAAKuQ,YAAY5O,SAC/Buf,EAAcja,EAAWC,sBAAsB+Z,EAAcjhB,KAAK8Q,SAAS7C,WAAYjO,KAAKuQ,YAAY/L,kBAErGa,EAAYC,kBAAkBtF,KAAKuQ,YAAY3O,WAChDsf,EAAclhB,KAAKuQ,YAAY3O,WACjCsf,EAAclhB,KAAKuQ,YAAY3O,SAC/Bqf,EAAcha,EAAWC,sBAAsBga,EAAclhB,KAAK8Q,SAAS7C,WAAYjO,KAAKuQ,YAAY/L,iBAG1GxE,KAAKqQ,aAAe4Q,EACpBjhB,KAAKsQ,cAAgB4Q,EACrBlhB,KAAK+V,kBACL/V,KAAKga,cAAc/U,EAAYC,IAAKlF,KAAKqW,gBAAgB4K,IACzDjhB,KAAKga,cAAc/U,EAAYE,IAAKnF,KAAKqW,gBAAgB6K,KAInD/R,EAAAjP,UAAA+e,uBAAR,SAA+BH,GAC7BA,EAAW9e,KAAK+hB,iBAAiBjD,GAC7B9e,KAAKmT,QACHnT,KAAKuQ,YAAY7O,UACnBod,EAAW9e,KAAKgiB,eAAelD,IAE3B9e,KAAKuQ,YAAYvM,cACfhE,KAAK0Q,yBAA2BzL,EAAYC,KAC5C4Z,EAAW9e,KAAKsQ,cAClBwO,EAAW9e,KAAKiiB,iBAAiBjiB,KAAKsQ,eAC7BtQ,KAAK0Q,yBAA2BzL,EAAYE,KAC5C2Z,EAAW9e,KAAKqQ,eACzByO,EAAW9e,KAAKiiB,iBAAiBjiB,KAAKqQ,gBAG1CyO,EAAW9e,KAAKiiB,iBAAiBnD,GAE7B9e,KAAK0Q,yBAA2BzL,EAAYC,KAAO4Z,EAAW9e,KAAKsQ,eACrEtQ,KAAKqQ,aAAerQ,KAAKsQ,cACzBtQ,KAAK+V,kBACL/V,KAAKga,cAAc/U,EAAYC,IAAKlF,KAAKwV,iBAAiBtH,UAC1DlO,KAAKyW,uBACLzW,KAAK0Q,uBAAyBzL,EAAYE,IAC1CnF,KAAKuV,iBAAiB7I,QAAS,EAC/B1M,KAAKwV,iBAAiB9I,QAAS,EAC3B1M,KAAKuQ,YAAY3M,iBACnB5D,KAAKwV,iBAAiBtI,SAEflN,KAAK0Q,yBAA2BzL,EAAYE,KAC5C2Z,EAAW9e,KAAKqQ,eACzBrQ,KAAKsQ,cAAgBtQ,KAAKqQ,aAC1BrQ,KAAK+V,kBACL/V,KAAKga,cAAc/U,EAAYE,IAAKnF,KAAKuV,iBAAiBrH,UAC1DlO,KAAKyW,uBACLzW,KAAK0Q,uBAAyBzL,EAAYC,IAC1ClF,KAAKwV,iBAAiB9I,QAAS,EAC/B1M,KAAKuV,iBAAiB7I,QAAS,EAC3B1M,KAAKuQ,YAAY3M,iBACnB5D,KAAKuV,iBAAiBrI,WAM1BlN,KAAKyV,4BAA8BqJ,IACjC9e,KAAK0Q,yBAA2BzL,EAAYC,KAC9ClF,KAAKqQ,aAAeyO,EACpB9e,KAAK+V,mBACI/V,KAAK0Q,yBAA2BzL,EAAYE,MACrDnF,KAAKsQ,cAAgBwO,EACrB9e,KAAK+V,mBAEP/V,KAAKga,cAAcha,KAAK0Q,uBAAwB1Q,KAAKqW,gBAAgByI,IACrE9e,KAAKyW,yBAIDtH,EAAAjP,UAAA6hB,iBAAR,SAAyBjD,GACvB,OAAKzZ,EAAYC,kBAAkBtF,KAAKuQ,YAAY5O,WAAamd,EAAW9e,KAAKuQ,YAAY5O,SACpF3B,KAAKuQ,YAAY5O,UAErB0D,EAAYC,kBAAkBtF,KAAKuQ,YAAY3O,WAAakd,EAAW9e,KAAKuQ,YAAY3O,SACpF5B,KAAKuQ,YAAY3O,SAEnBkd,GAGD3P,EAAAjP,UAAA+hB,iBAAR,SAAyBnD,OACjBoD,EAAyBliB,KAAK0Q,yBAA2BzL,EAAYC,IACvElF,KAAKsQ,cACLtQ,KAAKqQ,aACHpC,EAAqBrI,KAAKU,IAAIwY,EAAWoD,GAC/C,IAAK7c,EAAYC,kBAAkBtF,KAAKuQ,YAAY/O,WAC9CyM,EAAajO,KAAKuQ,YAAY/O,SAAU,CAC1C,GAAIxB,KAAK0Q,yBAA2BzL,EAAYC,IAC9C,OAAO+B,EAAWC,sBAAsBlH,KAAKsQ,cAAgBtQ,KAAKuQ,YAAY/O,SAAUxB,KAAKuQ,YAAY/L,gBACpG,GAAIxE,KAAK0Q,yBAA2BzL,EAAYE,IACrD,OAAO8B,EAAWC,sBAAsBlH,KAAKqQ,aAAerQ,KAAKuQ,YAAY/O,SAAUxB,KAAKuQ,YAAY/L,gBAI9G,IAAKa,EAAYC,kBAAkBtF,KAAKuQ,YAAY9O,WAC9CwM,EAAajO,KAAKuQ,YAAY9O,SAAU,CAC1C,GAAIzB,KAAK0Q,yBAA2BzL,EAAYC,IAC9C,OAAO+B,EAAWC,sBAAsBlH,KAAKsQ,cAAgBtQ,KAAKuQ,YAAY9O,SAAUzB,KAAKuQ,YAAY/L,gBACpG,GAAIxE,KAAK0Q,yBAA2BzL,EAAYE,IACrD,OAAO8B,EAAWC,sBAAsBlH,KAAKqQ,aAAerQ,KAAKuQ,YAAY9O,SAAUzB,KAAKuQ,YAAY/L,gBAI9G,OAAOsa,GAGD3P,EAAAjP,UAAA8hB,eAAR,SAAuBlD,OACf7Q,EAAsBjO,KAAK0Q,yBAA2BzL,EAAYC,IAChElF,KAAKsQ,cAAgBwO,EACrBA,EAAW9e,KAAKqQ,aAClB7O,EAAqB6D,EAAYC,kBAAkBtF,KAAKuQ,YAAY/O,UAElExB,KAAKuQ,YAAYhP,KADjBvB,KAAKuQ,YAAY/O,SAEnBC,EAAmBzB,KAAKuQ,YAAY9O,SA+B1C,OA7BIwM,EAAazM,GACXxB,KAAK0Q,yBAA2BzL,EAAYC,KAC9ClF,KAAKsQ,cAAgBrJ,EAAWC,sBAC9BtB,KAAKyB,IAAIyX,EAAWtd,EAAUxB,KAAKuQ,YAAYjP,MAAOtB,KAAKuQ,YAAY/L,gBACzEsa,EAAW7X,EAAWC,sBAAsBlH,KAAKsQ,cAAgB9O,EAAUxB,KAAKuQ,YAAY/L,gBAC5FxE,KAAK+V,kBACL/V,KAAKga,cAAc/U,EAAYE,IAAKnF,KAAKqW,gBAAgBrW,KAAKsQ,iBACrDtQ,KAAK0Q,yBAA2BzL,EAAYE,MACrDnF,KAAKqQ,aAAepJ,EAAWC,sBAC7BtB,KAAK0B,IAAIwX,EAAWtd,EAAUxB,KAAKuQ,YAAYlP,OAAQrB,KAAKuQ,YAAY/L,gBAC1Esa,EAAW7X,EAAWC,sBAAsBlH,KAAKqQ,aAAe7O,EAAUxB,KAAKuQ,YAAY/L,gBAC3FxE,KAAK+V,kBACL/V,KAAKga,cAAc/U,EAAYC,IAAKlF,KAAKqW,gBAAgBrW,KAAKqQ,gBAEhErQ,KAAKyW,yBACKpR,EAAYC,kBAAkB7D,IAAawM,EAAaxM,IAE9DzB,KAAK0Q,yBAA2BzL,EAAYC,KAC9ClF,KAAKsQ,cAAgBrJ,EAAWC,sBAAsB4X,EAAWrd,EAAUzB,KAAKuQ,YAAY/L,gBAC5FxE,KAAK+V,kBACL/V,KAAKga,cAAc/U,EAAYE,IAAKnF,KAAKqW,gBAAgBrW,KAAKsQ,iBAErDtQ,KAAK0Q,yBAA2BzL,EAAYE,MACrDnF,KAAKqQ,aAAepJ,EAAWC,sBAAsB4X,EAAWrd,EAAUzB,KAAKuQ,YAAY/L,gBAC3FxE,KAAK+V,kBACL/V,KAAKga,cAAc/U,EAAYC,IAAKlF,KAAKqW,gBAAgBrW,KAAKqQ,gBAEhErQ,KAAKyW,wBAEAqI,GAGD3P,EAAAjP,UAAA2W,iBAAR,eACQsL,EAA+B,IAAI/c,EAMzC,OALA+c,EAAc5P,YAAcvS,KAAK0Q,uBACjCyR,EAActhB,OAASb,KAAKa,MACxBb,KAAKmT,QACPgP,EAAc1T,WAAazO,KAAKyO,WAE3B0T,uBA1lEVC,EAAAA,UAASlW,KAAA,CAAC,CACTC,SAAU,aACVkW,SAAA,yoGAGAC,KAAM,CAAEC,MAAO,cACfC,UAAW,CAAC1T,svKAxHZzC,EAAAA,iBADAD,EAAAA,kBAMAqW,EAAAA,yBAGAC,EAAAA,yCAoHCC,EAAAA,2BAGAC,EAAAA,0BAIAD,EAAAA,+BAGAC,EAAAA,wBAKAD,EAAAA,+BAIAC,EAAAA,2BAIAA,EAAAA,8BAIAA,EAAAA,8BAKAD,EAAAA,4BAUAA,EAAAA,4CAoDAE,EAAAA,UAAS3W,KAAA,CAAC,wBAAyB,CAAC4W,KAAMvZ,EAAwBwZ,QAAQ,2CAI1EF,EAAAA,UAAS3W,KAAA,CAAC,yBAA0B,CAAC4W,KAAMvZ,EAAwBwZ,QAAQ,4BAI3EF,EAAAA,UAAS3W,KAAA,CAAC,UAAW,CAAC4W,KAAMvZ,EAAwBwZ,QAAQ,iCAI5DF,EAAAA,UAAS3W,KAAA,CAAC,eAAgB,CAAC4W,KAAMvZ,EAAwBwZ,QAAQ,8BAIjEF,EAAAA,UAAS3W,KAAA,CAAC,YAAa,CAAC4W,KAAMvW,EAAuBwW,QAAQ,8BAI7DF,EAAAA,UAAS3W,KAAA,CAAC,YAAa,CAAC4W,KAAMvW,EAAuBwW,QAAQ,+BAI7DF,EAAAA,UAAS3W,KAAA,CAAC,aAAc,CAAC4W,KAAM3V,EAAsB4V,QAAQ,8BAI7DF,EAAAA,UAAS3W,KAAA,CAAC,YAAa,CAAC4W,KAAM3V,EAAsB4V,QAAQ,mCAI5DF,EAAAA,UAAS3W,KAAA,CAAC,iBAAkB,CAAC4W,KAAM3V,EAAsB4V,QAAQ,mCAIjEF,EAAAA,UAAS3W,KAAA,CAAC,iBAAkB,CAAC4W,KAAM3V,EAAsB4V,QAAQ,kCAIjEF,EAAAA,UAAS3W,KAAA,CAAC,gBAAiB,CAAC4W,KAAM3V,EAAsB4V,QAAQ,0BAIhEF,EAAAA,UAAS3W,KAAA,CAAC,eAAgB,CAAC4W,KAAMvZ,EAAwBwZ,QAAQ,6BAIjEC,EAAAA,aAAY9W,KAAA,CAAC,kBAAmB,CAAC6W,QAAQ,wCAIzCzW,EAAAA,YAAWJ,KAAA,CAAC,qDAEZI,EAAAA,YAAWJ,KAAA,CAAC,oDAEZI,EAAAA,YAAWJ,KAAA,CAAC,mCAyJZ+W,EAAAA,aAAY/W,KAAA,CAAC,gBAAiB,CAAC,cAmyDlCiD,EA5lEA,GC7HA,IAAA+T,EAAA,WAEA,SAAAA,KAiBA,2BAjBCd,EAAAA,UAASlW,KAAA,CAAC,CACTC,SAAU,6BACVkW,SAAA,6cAICM,EAAAA,uBAGAA,EAAAA,yBAGAA,EAAAA,uBAGAA,EAAAA,SAEHO,EAnBA,GCaA,IAAAC,EAAA,WAAA,SAAAA,KAe+B,2BAf9BC,EAAAA,SAAQlX,KAAA,CAAC,CACRmX,QAAS,CACPC,EAAAA,cAEFC,aAAc,CACZpU,EACA5F,EACAgD,EACAY,EACA+V,GAEFM,QAAS,CACPrU,OAG2BgU,EAf/B","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","  // tslint:disable: no-inferrable-types\nimport { PointerType } from './pointer-type';\n\n/** Label type */\nexport enum LabelType {\n  /** Label above low pointer */\n  Low,\n  /** Label above high pointer */\n  High,\n  /** Label for minimum slider value */\n  Floor,\n  /** Label for maximum slider value */\n  Ceil,\n  /** Label below legend tick */\n  TickValue\n}\n\n/** Function to translate label value into text */\nexport type TranslateFunction = (value: number, label: LabelType) => string;\n/** Function to combind */\nexport type CombineLabelsFunction = (minLabel: string, maxLabel: string) => string;\n/** Function to provide legend  */\nexport type GetLegendFunction = (value: number) => string;\n\n/** Function converting slider value to slider position */\nexport type ValueToPositionFunction = (val: number, minVal: number, maxVal: number) => number;\n\n/** Function converting slider position to slider value */\nexport type PositionToValueFunction = (percent: number, minVal: number, maxVal: number) => number;\n\n/**\n * Custom step definition\n *\n * This can be used to specify custom values and legend values for slider ticks\n */\nexport interface CustomStepDefinition {\n  /** Value */\n  value: number;\n  /** Legend (label for the value) */\n  legend?: string;\n}\n\n/** Slider options */\nexport class Options {\n  /** Minimum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n  floor?: number = 0;\n\n  /** Maximum value for a slider.\n   * Not applicable when using stepsArray.\n   */\n  ceil?: number = null;\n\n  /** Step between each value.\n   * Not applicable when using stepsArray.\n   */\n  step?: number = 1;\n\n  /** The minimum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n  minRange?: number = null;\n\n  /** The maximum range authorized on the slider.\n   * Applies to range slider only.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n  maxRange?: number = null;\n\n  /** Set to true to have a push behavior. When the min handle goes above the max,\n   * the max is moved as well (and vice-versa). The range between min and max is\n   * defined by the step option (defaults to 1) and can also be overriden by\n   * the minRange option. Applies to range slider only.\n   */\n  pushRange?: boolean = false;\n\n  /** The minimum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n  minLimit?: number = null;\n\n  /** The maximum value authorized on the slider.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n  maxLimit?: number = null;\n\n  /** Custom translate function. Use this if you want to translate values displayed\n   * on the slider.\n   */\n  translate?: TranslateFunction = null;\n\n  /** Custom function for combining overlapping labels in range slider.\n   * It takes the min and max values (already translated with translate fuction)\n   * and should return how these two values should be combined.\n   * If not provided, the default function will join the two values with ' - ' as separator.\n   */\n  combineLabels?: CombineLabelsFunction = null;\n\n  /** Use to display legend under ticks (thus, it needs to be used along with\n   * showTicks or showTicksValues). The function will be called with each tick\n   * value and returned content will be displayed under the tick as a legend.\n   * If the returned value is null, then no legend is displayed under\n   * the corresponding tick.You can also directly provide the legend values\n   * in the stepsArray option.\n   */\n  getLegend?: GetLegendFunction = null;\n\n  /** If you want to display a slider with non linear/number steps.\n   * Just pass an array with each slider value and that's it; the floor, ceil and step settings\n   * of the slider will be computed automatically.\n   * By default, the value model and valueHigh model values will be the value of the selected item\n   * in the stepsArray.\n   * They can also be bound to the index of the selected item by setting the bindIndexForStepsArray\n   * option to true.\n   */\n  stepsArray?: CustomStepDefinition[] = null;\n\n  /** Set to true to bind the index of the selected item to value model and valueHigh model. */\n  bindIndexForStepsArray?: boolean = false;\n\n  /** When set to true and using a range slider, the range can be dragged by the selection bar.\n   * Applies to range slider only.\n   */\n  draggableRange?: boolean = false;\n\n  /** Same as draggableRange but the slider range can't be changed.\n   * Applies to range slider only.\n   */\n  draggableRangeOnly?: boolean = false;\n\n  /** Set to true to always show the selection bar before the slider handle. */\n  showSelectionBar?: boolean = false;\n\n  /** Set to true to always show the selection bar after the slider handle. */\n  showSelectionBarEnd?: boolean = false;\n\n  /**  Set a number to draw the selection bar between this value and the slider handle.\n   * When using stepsArray, expressed as index into stepsArray.\n   */\n  showSelectionBarFromValue?: number = null;\n\n  /**  Only for range slider. Set to true to visualize in different colour the areas\n   * on the left/right (top/bottom for vertical range slider) of selection bar between the handles.\n   */\n  showOuterSelectionBars?: boolean = false;\n\n  /** Set to true to hide pointer labels */\n  hidePointerLabels?: boolean = false;\n\n  /** Set to true to hide min / max labels  */\n  hideLimitLabels?: boolean = false;\n\n  /** Set to false to disable the auto-hiding behavior of the limit labels. */\n  autoHideLimitLabels?: boolean = true;\n\n  /** Set to true to make the slider read-only. */\n  readOnly?: boolean = false;\n\n  /** Set to true to disable the slider. */\n  disabled?: boolean = false;\n\n  /** Throttle interval for mouse events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with mouse.\n   */\n  mouseEventsInterval?: number = 50;\n\n  /** Throttle interval for touch events in milliseconds.\n   * This is provided to avoid a flood of events when moving the slider with touch gesture.\n   */\n  touchEventsInterval?: number = 50;\n\n  /** Throttle interval for input changes (changes to bindings or reactive form inputs)\n   * This is provided to avoid a flood of events on frequent input binding changes affecting performance.\n   */\n  inputEventsInterval?: number = 100;\n\n  /** Throttle interval for output changes (signalling changes to output bindings and user callbacks)\n   * This is provided to avoid a flood of outgoing events affecting Angular app performance.\n   */\n  outputEventsInterval?: number = 100;\n\n  /** Set to true to display a tick for each step of the slider. */\n  showTicks?: boolean = false;\n\n  /** Set to true to display a tick and the step value for each step of the slider.. */\n  showTicksValues?: boolean = false;\n\n  /* The step between each tick to display. If not set, the step value is used.\n    Not used when ticksArray is specified. */\n  tickStep?: number = null;\n\n  /* The step between displaying each tick step value. */\n  tickValueStep?: number = 1;\n\n  /** Use to display ticks at specific positions.\n   * The array contains the index of the ticks that should be displayed.\n   * For example, [0, 1, 5] will display a tick for the first, second and sixth values.\n   */\n  ticksArray?: number[] = null;\n\n  /** Used to display a tooltip when a tick is hovered.\n   * Set to a function that returns the tooltip content for a given value.\n   */\n  ticksTooltip?: (value: number) => string = null;\n\n  /** Same as ticksTooltip but for ticks values. */\n  ticksValuesTooltip?: (value: number) => string = null;\n\n  /** Set to true to display the slider vertically.\n   * The slider will take the full height of its parent.\n   * Changing this value at runtime is not currently supported.\n   */\n  vertical?: boolean = false;\n\n  /** Function that returns the current color of the selection bar.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model\n   * has already been updated.\n   */\n  getSelectionBarColor?: (minValue: number, maxValue?: number) => string = null;\n\n  /** Function that returns the color of a tick. showTicks must be enabled. */\n  getTickColor?: (value: number) => string = null;\n\n  /** Function that returns the current color of a pointer.\n   * If your color won't change, don't use this option but set it through CSS.\n   * If the returned color depends on a model value (either value or valueHigh),\n   * you should use the argument passed to the function.\n   * Indeed, when the function is called, there is no certainty that the model has already been updated.\n   * To handle range slider pointers independently, you should evaluate pointerType within the given\n   * function where \"min\" stands for value model and \"max\" for valueHigh model values.\n   */\n  getPointerColor?: (value: number, pointerType: PointerType) => string = null;\n\n  /** Handles are focusable (on click or with tab) and can be modified using the following keyboard controls:\n   * Left/bottom arrows: -1\n   * Right/top arrows: +1\n   * Page-down: -10%\n   * Page-up: +10%\n   * Home: minimum value\n   * End: maximum value\n   */\n  keyboardSupport?: boolean = true;\n\n  /** If you display the slider in an element that uses transform: scale(0.5), set the scale value to 2\n   * so that the slider is rendered properly and the events are handled correctly.\n   */\n  scale?: number = 1;\n\n  /** Set to true to force the value to be rounded to the step, even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, they are not rounded\n   * and can be between two steps.\n   */\n  enforceStep?: boolean = true;\n\n  /** Set to true to force the value to be normalised to allowed range (floor to ceil), even when modified from the outside.\n   * When set to false, if the model values are modified from outside the slider, and they are outside allowed range,\n   * the slider may be rendered incorrectly. However, setting this to false may be useful if you want to perform custom normalisation.\n   */\n  enforceRange?: boolean = true;\n\n  /** Set to true to prevent to user from switching the min and max handles. Applies to range slider only. */\n  noSwitching?: boolean = false;\n\n  /** Set to true to only bind events on slider handles. */\n  onlyBindHandles?: boolean = false;\n\n  /** Set to true to show graphs right to left.\n   * If vertical is true it will be from top to bottom and left / right arrow functions reversed.\n   */\n  rightToLeft?: boolean = false;\n\n  /** Set to true to reverse keyboard navigation:\n   * Right/top arrows: -1\n   * Left/bottom arrows: +1\n   * Page-up: -10%\n   * Page-down: +10%\n   * End: minimum value\n   * Home: maximum value\n   */\n  reversedControls?: boolean = false;\n\n  /** Set to true to keep the slider labels inside the slider bounds. */\n  boundPointerLabels?: boolean = true;\n\n  /** Set to true to use a logarithmic scale to display the slider.  */\n  logScale?: boolean = false;\n\n  /** Function that returns the position on the slider for a given value.\n   * The position must be a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n  customValueToPosition?: ValueToPositionFunction = null;\n\n  /** Function that returns the value for a given position on the slider.\n   * The position is a percentage between 0 and 1.\n   * The function should be monotonically increasing or decreasing; otherwise the slider may behave incorrectly.\n   */\n  customPositionToValue?: PositionToValueFunction = null;\n\n  /** Precision limit for calculated values.\n   * Values used in calculations will be rounded to this number of significant digits\n   * to prevent accumulating small floating-point errors.\n   */\n  precisionLimit?: number = 12;\n\n  /** Use to display the selection bar as a gradient.\n   * The given object must contain from and to properties which are colors.\n   */\n  selectionBarGradient?: {from: string, to: string} = null;\n\n  /** Use to add a label directly to the slider for accessibility. Adds the aria-label attribute. */\n  ariaLabel?: string = null;\n\n  /** Use instead of ariaLabel to reference the id of an element which will be used to label the slider.\n   * Adds the aria-labelledby attribute.\n   */\n  ariaLabelledBy?: string = null;\n\n  /** Use to add a label directly to the slider range for accessibility. Adds the aria-label attribute. */\n  ariaLabelHigh?: string = null;\n\n  /** Use instead of ariaLabelHigh to reference the id of an element which will be used to label the slider range.\n   * Adds the aria-labelledby attribute.\n   */\n  ariaLabelledByHigh?: string = null;\n\n  /** Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the handle */\n  handleDimension?: number = null;\n\n  /** Use to increase rendering performance. If the value is not provided, the slider calculates the with/height of the bar */\n  barDimension?: number = null;\n\n  /** Enable/disable CSS animations */\n  animate?: boolean = true;\n}\n","/** Pointer type */\nexport enum PointerType {\n  /** Low pointer */\n  Min,\n  /** High pointer */\n  Max\n}\n","import { PointerType } from './pointer-type';\n\nexport class ChangeContext {\n  value: number;\n  highValue?: number;\n  pointerType: PointerType;\n}\n","import { CustomStepDefinition } from '../interfaces/options';\n\n/**\n *  Collection of functions to handle conversions/lookups of values\n */\nexport class ValueHelper {\n  static isNullOrUndefined(value: any): boolean {\n    return value === undefined || value === null;\n  }\n\n  static linearValueToPosition(val: number, minVal: number, maxVal: number): number {\n    const range: number = maxVal - minVal;\n    return (val - minVal) / range;\n  }\n\n  static logValueToPosition(val: number, minVal: number, maxVal: number): number {\n    val = Math.log(val);\n    minVal = Math.log(minVal);\n    maxVal = Math.log(maxVal);\n    const range: number = maxVal - minVal;\n    return (val - minVal) / range;\n  }\n\n  static linearPositionToValue(percent: number, minVal: number, maxVal: number): number {\n    return percent * (maxVal - minVal) + minVal;\n  }\n\n  static logPositionToValue(percent: number, minVal: number, maxVal: number): number {\n    minVal = Math.log(minVal);\n    maxVal = Math.log(maxVal);\n    const value: number = percent * (maxVal - minVal) + minVal;\n    return Math.exp(value);\n  }\n\n  static findStepIndex(modelValue: number, stepsArray: CustomStepDefinition[]): number {\n    const differences: number[] = stepsArray.map((step: CustomStepDefinition): number => Math.abs(modelValue - step.value));\n\n    let minDifferenceIndex = 0;\n    for (let index = 0; index < stepsArray.length; index++) {\n      if (differences[index] !== differences[minDifferenceIndex] && differences[index] < differences[minDifferenceIndex]) {\n        minDifferenceIndex = index;\n      }\n    }\n\n    return minDifferenceIndex;\n  }\n}\n","// Declaration for ResizeObserver a new API available in some of newest browsers:\n// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\ndeclare class ResizeObserver {\n}\n\n/** Helper with compatibility functions to support different browsers */\nexport class CompatibilityHelper {\n  /** Workaround for TouchEvent constructor sadly not being available on all browsers (e.g. Firefox, Safari) */\n  public static isTouchEvent(event: any): boolean {\n    if ((window as any).TouchEvent !== undefined) {\n      return event instanceof TouchEvent;\n    }\n\n    return event.touches !== undefined;\n  }\n\n  /** Detect presence of ResizeObserver API */\n  public static isResizeObserverAvailable(): boolean {\n    return (window as any).ResizeObserver !== undefined;\n  }\n}\n","/** Helper with mathematical functions */\nexport class MathHelper {\n  /* Round numbers to a given number of significant digits */\n  static roundToPrecisionLimit(value: number, precisionLimit: number): number {\n    return +( value.toPrecision(precisionLimit) );\n  }\n\n  static clampToRange(value: number, floor: number, ceil: number): number {\n    return Math.min(Math.max(value, floor), ceil);\n  }\n}\n","import { Subject, Subscription } from 'rxjs';\n\nexport class EventListener {\n  eventName: string = null;\n  events: Subject<Event> = null;\n  eventsSubscription: Subscription = null;\n  teardownCallback: () => void = null;\n}\n","import { Renderer2 } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { throttleTime, tap } from 'rxjs/operators';\nimport detectPassiveEvents from 'detect-passive-events';\n\nimport { EventListener } from '../interfaces/event-listener';\nimport { ValueHelper } from './value-helper';\n\n/**\n * Helper class to attach event listeners to DOM elements with debounce support using rxjs\n */\nexport class EventListenerHelper {\n  constructor(private renderer: Renderer2) {\n  }\n\n  public attachPassiveEventListener(nativeElement: any, eventName: string, callback: (event: any) => void,\n                                    throttleInterval?: number): EventListener {\n    // Only use passive event listeners if the browser supports it\n    if (detectPassiveEvents.hasSupport !== true) {\n      return this.attachEventListener(nativeElement, eventName, callback, throttleInterval);\n    }\n\n    // Angular doesn't support passive event handlers (yet), so we need to roll our own code using native functions\n    const listener: EventListener = new EventListener();\n    listener.eventName = eventName;\n    listener.events = new Subject<Event>();\n\n    const observerCallback: (event: Event) => void = (event: Event): void => {\n      listener.events.next(event);\n    };\n    nativeElement.addEventListener(eventName, observerCallback, {passive: true, capture: false});\n\n    listener.teardownCallback = (): void => {\n      nativeElement.removeEventListener(eventName, observerCallback, {passive: true, capture: false});\n    };\n\n    listener.eventsSubscription = listener.events\n      .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n        ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true})\n        : tap(() => {}) // no-op\n      )\n      .subscribe((event: Event) => {\n        callback(event);\n      });\n\n    return listener;\n  }\n\n  public detachEventListener(eventListener: EventListener): void {\n    if (!ValueHelper.isNullOrUndefined(eventListener.eventsSubscription)) {\n      eventListener.eventsSubscription.unsubscribe();\n      eventListener.eventsSubscription = null;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(eventListener.events)) {\n      eventListener.events.complete();\n      eventListener.events = null;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(eventListener.teardownCallback)) {\n      eventListener.teardownCallback();\n      eventListener.teardownCallback = null;\n    }\n  }\n\n  public attachEventListener(nativeElement: any, eventName: string, callback: (event: any) => void,\n                             throttleInterval?: number): EventListener {\n    const listener: EventListener = new EventListener();\n    listener.eventName = eventName;\n    listener.events = new Subject<Event>();\n\n    const observerCallback: (event: Event) => void = (event: Event): void => {\n      listener.events.next(event);\n    };\n\n    listener.teardownCallback = this.renderer.listen(nativeElement, eventName, observerCallback);\n\n    listener.eventsSubscription = listener.events\n      .pipe((!ValueHelper.isNullOrUndefined(throttleInterval))\n          ? throttleTime(throttleInterval, undefined, { leading: true, trailing: true})\n          : tap(() => {}) // no-op\n      )\n      .subscribe((event: Event) => { callback(event); });\n\n    return listener;\n  }\n}\n","  // tslint:disable: variable-name\nimport { Directive, ElementRef, Renderer2, HostBinding } from '@angular/core';\nimport { EventListenerHelper } from '../helpers/event-listener-helper';\nimport { EventListener } from '../interfaces/event-listener';\nimport { ValueHelper } from '../helpers/value-helper';\n\n@Directive({\n  selector: '[ngxSliderElement]'\n})\nexport class SliderElementDirective {\n  private _position = 0;\n  get position(): number {\n    return this._position;\n  }\n\n  private _dimension = 0;\n  get dimension(): number {\n    return this._dimension;\n  }\n\n  private _alwaysHide = false;\n  get alwaysHide(): boolean {\n    return this._alwaysHide;\n  }\n\n  private _vertical = false;\n  get vertical(): boolean {\n    return this._vertical;\n  }\n\n  private _scale = 1;\n  get scale(): number {\n    return this._scale;\n  }\n\n  @HostBinding('style.opacity')\n  opacity = 1;\n\n  @HostBinding('style.visibility')\n  visibility = 'visible';\n\n  @HostBinding('style.left')\n  left = '';\n\n  @HostBinding('style.bottom')\n  bottom = '';\n\n  @HostBinding('style.height')\n  height = '';\n\n  @HostBinding('style.width')\n  width = '';\n\n  private eventListenerHelper: EventListenerHelper;\n  private eventListeners: EventListener[] = [];\n\n  constructor(protected elemRef: ElementRef, protected renderer: Renderer2) {\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n\n  setAlwaysHide(hide: boolean): void {\n    this._alwaysHide = hide;\n    if (hide) {\n      this.visibility = 'hidden';\n    } else {\n      this.visibility = 'visible';\n    }\n  }\n\n  hide(): void {\n    this.opacity = 0;\n  }\n\n  show(): void {\n    if (this.alwaysHide) {\n      return;\n    }\n\n    this.opacity = 1;\n  }\n\n  isVisible(): boolean {\n    if (this.alwaysHide) {\n      return false;\n    }\n    return this.opacity !== 0;\n  }\n\n  setVertical(vertical: boolean): void {\n    this._vertical = vertical;\n    if (this._vertical) {\n      this.left = '';\n      this.width = '';\n    } else {\n      this.bottom = '';\n      this.height = '';\n    }\n  }\n\n  setScale(scale: number): void {\n    this._scale = scale;\n  }\n\n   // Set element left/top position depending on whether slider is horizontal or vertical\n  setPosition(pos: number): void {\n    this._position = pos;\n    if (this._vertical) {\n      this.bottom = Math.round(pos) + 'px';\n    } else {\n      this.left = Math.round(pos) + 'px';\n    }\n  }\n\n  // Calculate element's width/height depending on whether slider is horizontal or vertical\n  calculateDimension(): void {\n    const val: ClientRect = this.getBoundingClientRect();\n    if (this.vertical) {\n      this._dimension = (val.bottom - val.top) * this.scale;\n    } else {\n      this._dimension = (val.right - val.left) * this.scale;\n    }\n  }\n\n  // Set element width/height depending on whether slider is horizontal or vertical\n  setDimension(dim: number): void {\n    this._dimension = dim;\n    if (this._vertical) {\n      this.height = Math.round(dim) + 'px';\n    } else {\n      this.width = Math.round(dim) + 'px';\n    }\n  }\n\n  getBoundingClientRect(): ClientRect {\n    return this.elemRef.nativeElement.getBoundingClientRect();\n  }\n\n  on(eventName: string, callback: (event: any) => void, debounceInterval?: number): void {\n    const listener: EventListener = this.eventListenerHelper.attachEventListener(\n      this.elemRef.nativeElement, eventName, callback, debounceInterval);\n    this.eventListeners.push(listener);\n  }\n\n  onPassive(eventName: string, callback: (event: any) => void, debounceInterval?: number): void {\n    const listener: EventListener = this.eventListenerHelper.attachPassiveEventListener(\n      this.elemRef.nativeElement, eventName, callback, debounceInterval);\n    this.eventListeners.push(listener);\n  }\n\n  off(eventName?: string): void {\n    let listenersToKeep: EventListener[];\n    let listenersToRemove: EventListener[];\n    if (!ValueHelper.isNullOrUndefined(eventName)) {\n      listenersToKeep = this.eventListeners.filter((event: EventListener) => event.eventName !== eventName);\n      listenersToRemove = this.eventListeners.filter((event: EventListener) => event.eventName === eventName);\n    } else {\n      listenersToKeep = [];\n      listenersToRemove = this.eventListeners;\n    }\n\n    for (const listener of listenersToRemove) {\n      this.eventListenerHelper.detachEventListener(listener);\n    }\n\n    this.eventListeners = listenersToKeep;\n  }\n}\n","import { Directive, ElementRef, Renderer2, HostBinding } from '@angular/core';\nimport { SliderElementDirective } from './slider-element.directive';\n\n@Directive({\n  selector: '[ngxSliderHandle]'\n})\nexport class SliderHandleDirective extends SliderElementDirective {\n  @HostBinding('class.ngx-slider-active')\n  active = false;\n\n  @HostBinding('attr.role')\n  role = '';\n\n  @HostBinding('attr.tabindex')\n  tabindex = '';\n\n  @HostBinding('attr.aria-orientation')\n  ariaOrientation = '';\n\n  @HostBinding('attr.aria-label')\n  ariaLabel = '';\n\n  @HostBinding('attr.aria-labelledby')\n  ariaLabelledBy = '';\n\n  @HostBinding('attr.aria-valuenow')\n  ariaValueNow = '';\n\n  @HostBinding('attr.aria-valuetext')\n  ariaValueText = '';\n\n  @HostBinding('attr.aria-valuemin')\n  ariaValueMin = '';\n\n  @HostBinding('attr.aria-valuemax')\n  ariaValueMax = '';\n\n  focus(): void {\n    this.elemRef.nativeElement.focus();\n  }\n\n  constructor(elemRef: ElementRef, renderer: Renderer2) {\n    super(elemRef, renderer);\n  }\n}\n","import { Directive, ElementRef, Renderer2 } from '@angular/core';\nimport { SliderElementDirective } from './slider-element.directive';\nimport { ValueHelper } from '../helpers/value-helper';\n\n@Directive({\n  selector: '[ngxSliderLabel]'\n})\nexport class SliderLabelDirective extends SliderElementDirective {\n  // tslint:disable-next-line: variable-name\n  private _value: string = null;\n  get value(): string {\n    return this._value;\n  }\n\n  constructor(elemRef: ElementRef, renderer: Renderer2) {\n    super(elemRef, renderer);\n  }\n\n  setValue(value: string): void {\n    let recalculateDimension = false;\n\n    if (!this.alwaysHide &&\n        (ValueHelper.isNullOrUndefined(this.value) ||\n         this.value.length !== value.length ||\n         (this.value.length > 0 && this.dimension === 0))) {\n      recalculateDimension = true;\n    }\n\n    this._value = value;\n    this.elemRef.nativeElement.innerHTML = value;\n\n    // Update dimension only when length of the label have changed\n    if (recalculateDimension) {\n      this.calculateDimension();\n    }\n  }\n}\n","import {\n  Component,\n  OnInit,\n  ViewChild,\n  AfterViewInit,\n  OnChanges,\n  OnDestroy,\n  HostBinding,\n  HostListener,\n  Input,\n  ElementRef,\n  Renderer2,\n  EventEmitter,\n  Output,\n  ContentChild,\n  TemplateRef,\n  ChangeDetectorRef,\n  SimpleChanges,\n  forwardRef,\n  NgZone\n} from '@angular/core';\n\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\nimport { Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged, filter, throttleTime, tap } from 'rxjs/operators';\n\nimport detectPassiveEvents from 'detect-passive-events';\n\nimport {\n  Options,\n  LabelType,\n  ValueToPositionFunction,\n  PositionToValueFunction,\n  CustomStepDefinition\n} from '../interfaces/options';\nimport { PointerType } from '../interfaces/pointer-type';\nimport { ChangeContext } from '../interfaces/change-context';\nimport { ValueHelper } from '../helpers/value-helper';\nimport { CompatibilityHelper } from '../helpers/compatibility-helper';\nimport { MathHelper } from '../helpers/math-helper';\nimport { EventListener } from '../interfaces/event-listener';\nimport { EventListenerHelper } from '../helpers/event-listener-helper';\nimport { SliderElementDirective } from '../directives/slider-element.directive';\nimport { SliderHandleDirective } from '../directives/slider-handle.directive';\nimport { SliderLabelDirective } from '../directives/slider-label.directive';\n\n// Declaration for ResizeObserver a new API available in some of newest browsers:\n// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\ndeclare class ResizeObserver {\n  constructor(callback: () => void);\n  observe(target: any): void;\n  unobserve(target: any): void;\n  disconnect(): void;\n}\n\nexport class Tick {\n  selected = false;\n  style: any = {};\n  tooltip: string = null;\n  tooltipPlacement: string = null;\n  value: string = null;\n  valueTooltip: string = null;\n  valueTooltipPlacement: string = null;\n  legend: string = null;\n}\n\nclass Dragging {\n  active = false;\n  value = 0;\n  difference = 0;\n  position = 0;\n  lowLimit = 0;\n  highLimit = 0;\n}\n\nclass ModelValues {\n  value: number;\n  highValue: number;\n\n  public static compare(x?: ModelValues, y?: ModelValues): boolean {\n    if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    return x.value === y.value && x.highValue === y.highValue;\n  }\n}\n\nclass ModelChange extends ModelValues {\n  // Flag used to by-pass distinctUntilChanged() filter on input values\n  // (sometimes there is a need to pass values through even though the model values have not changed)\n  forceChange: boolean;\n\n  public static compare(x?: ModelChange, y?: ModelChange): boolean {\n    if (ValueHelper.isNullOrUndefined(x) && ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    if (ValueHelper.isNullOrUndefined(x) !== ValueHelper.isNullOrUndefined(y)) {\n      return false;\n    }\n    return x.value === y.value &&\n           x.highValue === y.highValue &&\n           x.forceChange === y.forceChange;\n  }\n}\n\nclass InputModelChange extends ModelChange {\n  internalChange: boolean;\n}\n\nclass OutputModelChange extends ModelChange {\n  userEventInitiated: boolean;\n}\n\nconst NGX_SLIDER_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(() => SliderComponent),\n  multi: true,\n};\n\n\n@Component({\n  selector: 'ngx-slider',\n  templateUrl: './slider.component.html',\n  styleUrls: ['./slider.component.scss'],\n  // tslint:disable-next-line: no-host-metadata-property\n  host: { class: 'ngx-slider' },\n  providers: [NGX_SLIDER_CONTROL_VALUE_ACCESSOR]\n})\nexport class SliderComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy, ControlValueAccessor {\n  // Model for low value of slider. For simple slider, this is the only input. For range slider, this is the low value.\n  @Input()\n  public value: number = null;\n  // Output for low value slider to support two-way bindings\n  @Output()\n  public valueChange: EventEmitter<number> = new EventEmitter();\n\n  // Model for high value of slider. Not used in simple slider. For range slider, this is the high value.\n  @Input()\n  public highValue: number = null;\n  // Output for high value slider to support two-way bindings\n  @Output()\n  public highValueChange: EventEmitter<number> = new EventEmitter();\n\n  // An object with all the other options of the slider.\n  // Each option can be updated at runtime and the slider will automatically be re-rendered.\n  @Input()\n  public options: Options = new Options();\n\n  // Event emitted when user starts interaction with the slider\n  @Output()\n  public userChangeStart: EventEmitter<ChangeContext> = new EventEmitter();\n\n  // Event emitted on each change coming from user interaction\n  @Output()\n  public userChange: EventEmitter<ChangeContext> = new EventEmitter();\n\n  // Event emitted when user finishes interaction with the slider\n  @Output()\n  public userChangeEnd: EventEmitter<ChangeContext> = new EventEmitter();\n\n  private manualRefreshSubscription: any;\n  // Input event that triggers slider refresh (re-positioning of slider elements)\n  @Input() set manualRefresh(manualRefresh: EventEmitter<void>) {\n    this.unsubscribeManualRefresh();\n\n    this.manualRefreshSubscription = manualRefresh.subscribe(() => {\n      setTimeout(() => this.calculateViewDimensionsAndDetectChanges());\n    });\n  }\n\n  private triggerFocusSubscription: any;\n  // Input event that triggers setting focus on given slider handle\n  @Input() set triggerFocus(triggerFocus: EventEmitter<void>) {\n    this.unsubscribeTriggerFocus();\n\n    this.triggerFocusSubscription = triggerFocus.subscribe((pointerType: PointerType) => {\n      this.focusPointer(pointerType);\n    });\n  }\n\n  // Slider type, true means range slider\n  public get range(): boolean {\n    return !ValueHelper.isNullOrUndefined(this.value) && !ValueHelper.isNullOrUndefined(this.highValue);\n  }\n\n  // Set to true if init method already executed\n  private initHasRun = false;\n\n  // Changes in model inputs are passed through this subject\n  // These are all changes coming in from outside the component through input bindings or reactive form inputs\n  private inputModelChangeSubject: Subject<InputModelChange> = new Subject<InputModelChange>();\n  private inputModelChangeSubscription: Subscription = null;\n\n  // Changes to model outputs are passed through this subject\n  // These are all changes that need to be communicated to output emitters and registered callbacks\n  private outputModelChangeSubject: Subject<OutputModelChange> = new Subject<OutputModelChange>();\n  private outputModelChangeSubscription: Subscription = null;\n\n  // Low value synced to model low value\n  private viewLowValue: number = null;\n  // High value synced to model high value\n  private viewHighValue: number = null;\n  // Options synced to model options, based on defaults\n  private viewOptions: Options = new Options();\n\n  // Half of the width or height of the slider handles\n  private handleHalfDimension = 0;\n  // Maximum position the slider handle can have\n  private maxHandlePosition = 0;\n\n  // Which handle is currently tracked for move events\n  private currentTrackingPointer: PointerType = null;\n  // Internal variable to keep track of the focus element\n  private currentFocusPointer: PointerType = null;\n  // Used to call onStart on the first keydown event\n  private firstKeyDown = false;\n  // Current touch id of touch event being handled\n  private touchId: number = null;\n  // Values recorded when first dragging the bar\n  private dragging: Dragging = new Dragging();\n\n  /* Slider DOM elements */\n\n  // Left selection bar outside two handles\n  @ViewChild('leftOuterSelectionBar', {read: SliderElementDirective, static: false})\n  private leftOuterSelectionBarElement: SliderElementDirective;\n\n  // Right selection bar outside two handles\n  @ViewChild('rightOuterSelectionBar', {read: SliderElementDirective, static: false})\n  private rightOuterSelectionBarElement: SliderElementDirective;\n\n  // The whole slider bar\n  @ViewChild('fullBar', {read: SliderElementDirective, static: false})\n  private fullBarElement: SliderElementDirective;\n\n  // Highlight between two handles\n  @ViewChild('selectionBar', {read: SliderElementDirective, static: false})\n  private selectionBarElement: SliderElementDirective;\n\n  // Left slider handle\n  @ViewChild('minHandle', {read: SliderHandleDirective, static: false})\n  private minHandleElement: SliderHandleDirective;\n\n  // Right slider handle\n  @ViewChild('maxHandle', {read: SliderHandleDirective, static: false})\n  private maxHandleElement: SliderHandleDirective;\n\n  // Floor label\n  @ViewChild('floorLabel', {read: SliderLabelDirective, static: false})\n  private floorLabelElement: SliderLabelDirective;\n\n  // Ceiling label\n  @ViewChild('ceilLabel', {read: SliderLabelDirective, static: false})\n  private ceilLabelElement: SliderLabelDirective;\n\n  // Label above the low value\n  @ViewChild('minHandleLabel', {read: SliderLabelDirective, static: false})\n  private minHandleLabelElement: SliderLabelDirective;\n\n  // Label above the high value\n  @ViewChild('maxHandleLabel', {read: SliderLabelDirective, static: false})\n  private maxHandleLabelElement: SliderLabelDirective;\n\n  // Combined label\n  @ViewChild('combinedLabel', {read: SliderLabelDirective, static: false})\n  private combinedLabelElement: SliderLabelDirective;\n\n  // The ticks\n  @ViewChild('ticksElement', {read: SliderElementDirective, static: false})\n  private ticksElement: SliderElementDirective;\n\n  // Optional custom template for displaying tooltips\n  @ContentChild('tooltipTemplate', {static: false})\n  public tooltipTemplate: TemplateRef<any>;\n\n  // Host element class bindings\n  @HostBinding('class.vertical')\n  public sliderElementVerticalClass = false;\n  @HostBinding('class.animate')\n  public sliderElementAnimateClass = false;\n  @HostBinding('attr.disabled')\n  public sliderElementDisabledAttr: string = null;\n\n  // CSS styles and class flags\n  public barStyle: any = {};\n  public minPointerStyle: any = {};\n  public maxPointerStyle: any = {};\n  public fullBarTransparentClass = false;\n  public selectionBarDraggableClass = false;\n  public ticksUnderValuesClass = false;\n\n  // Whether to show/hide ticks\n  public get showTicks(): boolean {\n    return this.viewOptions.showTicks;\n  }\n\n  /* If tickStep is set or ticksArray is specified.\n     In this case, ticks values should be displayed below the slider. */\n  private intermediateTicks = false;\n  // Ticks array as displayed in view\n  public ticks: Tick[] = [];\n\n  // Event listeners\n  private eventListenerHelper: EventListenerHelper = null;\n  private onMoveEventListener: EventListener = null;\n  private onEndEventListener: EventListener = null;\n\n  // Observer for slider element resize events\n  private resizeObserver: ResizeObserver = null;\n\n  // Callbacks for reactive forms support\n  private onTouchedCallback: (value: any) => void = null;\n  private onChangeCallback: (value: any) => void = null;\n\n\n  public constructor(private renderer: Renderer2,\n                     private elementRef: ElementRef,\n                     private changeDetectionRef: ChangeDetectorRef,\n                     private zone: NgZone) {\n    this.eventListenerHelper = new EventListenerHelper(this.renderer);\n  }\n\n  // OnInit interface\n  public ngOnInit(): void {\n    this.viewOptions = new Options();\n    Object.assign(this.viewOptions, this.options);\n\n    // We need to run these two things first, before the rest of the init in ngAfterViewInit(),\n    // because these two settings are set through @HostBinding and Angular change detection\n    // mechanism doesn't like them changing in ngAfterViewInit()\n    this.updateDisabledState();\n    this.updateVerticalState();\n  }\n\n  // AfterViewInit interface\n  public ngAfterViewInit(): void {\n    this.applyOptions();\n\n    this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n    this.subscribeOutputModelChangeSubject(this.viewOptions.outputEventsInterval);\n\n    // Once we apply options, we need to normalise model values for the first time\n    this.renormaliseModelValues();\n\n    this.viewLowValue = this.modelValueToViewValue(this.value);\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(this.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.updateVerticalState(); // need to run this again to cover changes to slider elements\n    this.manageElementsStyle();\n    this.updateDisabledState();\n    this.calculateViewDimensions();\n    this.addAccessibility();\n    this.updateCeilLabel();\n    this.updateFloorLabel();\n    this.initHandles();\n    this.manageEventsBindings();\n\n    this.subscribeResizeObserver();\n\n    this.initHasRun = true;\n\n    // Run change detection manually to resolve some issues when init procedure changes values used in the view\n    this.changeDetectionRef.detectChanges();\n  }\n\n  // OnChanges interface\n  public ngOnChanges(changes: SimpleChanges): void {\n    // Always apply options first\n    if (!ValueHelper.isNullOrUndefined(changes.options)) {\n      this.onChangeOptions();\n    }\n\n    // Then value changes\n    if (!ValueHelper.isNullOrUndefined(changes.value) ||\n        !ValueHelper.isNullOrUndefined(changes.highValue)) {\n      this.inputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: false,\n        internalChange: false\n      });\n    }\n  }\n\n  // OnDestroy interface\n  public ngOnDestroy(): void {\n    this.unbindEvents();\n\n    this.unsubscribeResizeObserver();\n    this.unsubscribeInputModelChangeSubject();\n    this.unsubscribeOutputModelChangeSubject();\n    this.unsubscribeManualRefresh();\n    this.unsubscribeTriggerFocus();\n  }\n\n  // ControlValueAccessor interface\n  public writeValue(obj: any): void {\n    if (obj instanceof Array) {\n      this.value = obj[0];\n      this.highValue = obj[1];\n    } else {\n      this.value = obj;\n    }\n\n    // ngOnChanges() is not called in this instance, so we need to communicate the change manually\n    this.inputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      forceChange: false,\n      internalChange: false\n    });\n  }\n\n  // ControlValueAccessor interface\n  public registerOnChange(onChangeCallback: any): void {\n    this.onChangeCallback = onChangeCallback;\n  }\n\n  // ControlValueAccessor interface\n  public registerOnTouched(onTouchedCallback: any): void {\n    this.onTouchedCallback = onTouchedCallback;\n  }\n\n  // ControlValueAccessor interface\n  public setDisabledState(isDisabled: boolean): void {\n    this.viewOptions.disabled = isDisabled;\n    this.updateDisabledState();\n  }\n\n  @HostListener('window:resize', ['$event'])\n  public onResize(event: any): void {\n    this.calculateViewDimensionsAndDetectChanges();\n  }\n\n  private subscribeInputModelChangeSubject(interval?: number): void {\n    this.inputModelChangeSubscription = this.inputModelChangeSubject\n    .pipe(\n      distinctUntilChanged(ModelChange.compare),\n      // Hack to reset the status of the distinctUntilChanged() - if a \"fake\" event comes through with forceChange=true,\n      // we forcefully by-pass distinctUntilChanged(), but otherwise drop the event\n      filter((modelChange: InputModelChange) => !modelChange.forceChange && !modelChange.internalChange),\n      (!ValueHelper.isNullOrUndefined(interval))\n          ? throttleTime(interval, undefined, { leading: true, trailing: true})\n          : tap(() => {}) // no-op\n    )\n    .subscribe((modelChange: InputModelChange) => this.applyInputModelChange(modelChange));\n  }\n\n  private subscribeOutputModelChangeSubject(interval?: number): void {\n    this.outputModelChangeSubscription = this.outputModelChangeSubject\n      .pipe(\n        distinctUntilChanged(ModelChange.compare),\n        (!ValueHelper.isNullOrUndefined(interval))\n          ? throttleTime(interval, undefined, { leading: true, trailing: true})\n          : tap(() => {}) // no-op\n      )\n      .subscribe((modelChange: OutputModelChange) => this.publishOutputModelChange(modelChange));\n  }\n\n  private subscribeResizeObserver(): void {\n    if (CompatibilityHelper.isResizeObserverAvailable()) {\n      this.resizeObserver = new ResizeObserver((): void => this.calculateViewDimensionsAndDetectChanges());\n      this.resizeObserver.observe(this.elementRef.nativeElement);\n    }\n  }\n\n  private unsubscribeResizeObserver(): void {\n    if (CompatibilityHelper.isResizeObserverAvailable() && this.resizeObserver !== null) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n  }\n\n  private unsubscribeOnMove(): void {\n    if (!ValueHelper.isNullOrUndefined(this.onMoveEventListener)) {\n      this.eventListenerHelper.detachEventListener(this.onMoveEventListener);\n      this.onMoveEventListener = null;\n    }\n  }\n\n  private unsubscribeOnEnd(): void {\n    if (!ValueHelper.isNullOrUndefined(this.onEndEventListener)) {\n      this.eventListenerHelper.detachEventListener(this.onEndEventListener);\n      this.onEndEventListener = null;\n    }\n  }\n\n  private unsubscribeInputModelChangeSubject(): void {\n    if (!ValueHelper.isNullOrUndefined(this.inputModelChangeSubscription)) {\n      this.inputModelChangeSubscription.unsubscribe();\n      this.inputModelChangeSubscription = null;\n    }\n  }\n\n  private unsubscribeOutputModelChangeSubject(): void {\n    if (!ValueHelper.isNullOrUndefined(this.outputModelChangeSubscription)) {\n      this.outputModelChangeSubscription.unsubscribe();\n      this.outputModelChangeSubscription = null;\n    }\n  }\n\n  private unsubscribeManualRefresh(): void {\n    if (!ValueHelper.isNullOrUndefined(this.manualRefreshSubscription)) {\n      this.manualRefreshSubscription.unsubscribe();\n      this.manualRefreshSubscription = null;\n    }\n  }\n\n  private unsubscribeTriggerFocus(): void {\n    if (!ValueHelper.isNullOrUndefined(this.triggerFocusSubscription)) {\n      this.triggerFocusSubscription.unsubscribe();\n      this.triggerFocusSubscription = null;\n    }\n  }\n\n  private getPointerElement(pointerType: PointerType): SliderHandleDirective {\n    if (pointerType === PointerType.Min) {\n      return this.minHandleElement;\n    } else if (pointerType === PointerType.Max) {\n      return this.maxHandleElement;\n    }\n    return null;\n  }\n\n  private getCurrentTrackingValue(): number {\n    if (this.currentTrackingPointer === PointerType.Min) {\n      return this.viewLowValue;\n    } else if (this.currentTrackingPointer === PointerType.Max) {\n      return this.viewHighValue;\n    }\n    return null;\n  }\n\n  private modelValueToViewValue(modelValue: number): number {\n    if (ValueHelper.isNullOrUndefined(modelValue)) {\n      return NaN;\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      return ValueHelper.findStepIndex(+modelValue, this.viewOptions.stepsArray);\n    }\n    return +modelValue;\n  }\n\n  private viewValueToModelValue(viewValue: number): number {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      return this.getStepValue(viewValue);\n    }\n    return viewValue;\n  }\n\n  private getStepValue(sliderValue: number): number {\n    const step: CustomStepDefinition = this.viewOptions.stepsArray[sliderValue];\n    return (!ValueHelper.isNullOrUndefined(step)) ? step.value : NaN;\n  }\n\n  private applyViewChange(): void {\n    this.value = this.viewValueToModelValue(this.viewLowValue);\n    if (this.range) {\n      this.highValue = this.viewValueToModelValue(this.viewHighValue);\n    }\n\n    this.outputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      userEventInitiated: true,\n      forceChange: false\n    });\n\n    // At this point all changes are applied and outputs are emitted, so we should be done.\n    // However, input changes are communicated in different stream and we need to be ready to\n    // act on the next input change even if it is exactly the same as last input change.\n    // Therefore, we send a special event to reset the stream.\n    this.inputModelChangeSubject.next({\n      value: this.value,\n      highValue: this.highValue,\n      forceChange: false,\n      internalChange: true\n    });\n  }\n\n  // Apply model change to the slider view\n  private applyInputModelChange(modelChange: InputModelChange): void {\n    const normalisedModelChange: ModelValues = this.normaliseModelValues(modelChange);\n\n    // If normalised model change is different, apply the change to the model values\n    const normalisationChange: boolean = !ModelValues.compare(modelChange, normalisedModelChange);\n    if (normalisationChange) {\n      this.value = normalisedModelChange.value;\n      this.highValue = normalisedModelChange.highValue;\n    }\n\n    this.viewLowValue = this.modelValueToViewValue(normalisedModelChange.value);\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(normalisedModelChange.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n    if (this.range) {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n    }\n    this.updateSelectionBar();\n    this.updateTicksScale();\n    this.updateAriaAttributes();\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n\n    // At the end, we need to communicate the model change to the outputs as well\n    // Normalisation changes are also always forced out to ensure that subscribers always end up in correct state\n    this.outputModelChangeSubject.next({\n      value: normalisedModelChange.value,\n      highValue: normalisedModelChange.highValue,\n      forceChange: normalisationChange,\n      userEventInitiated: false\n    });\n  }\n\n  // Publish model change to output event emitters and registered callbacks\n  private publishOutputModelChange(modelChange: OutputModelChange): void {\n    const emitOutputs: () => void = (): void => {\n      this.valueChange.emit(modelChange.value);\n      if (this.range) {\n        this.highValueChange.emit(modelChange.highValue);\n      }\n\n      if (!ValueHelper.isNullOrUndefined(this.onChangeCallback)) {\n        if (this.range) {\n          this.onChangeCallback([modelChange.value, modelChange.highValue]);\n        } else {\n          this.onChangeCallback(modelChange.value);\n        }\n      }\n      if (!ValueHelper.isNullOrUndefined(this.onTouchedCallback)) {\n        if (this.range) {\n          this.onTouchedCallback([modelChange.value, modelChange.highValue]);\n        } else {\n          this.onTouchedCallback(modelChange.value);\n        }\n      }\n    };\n\n    if (modelChange.userEventInitiated) {\n      // If this change was initiated by a user event, we can emit outputs in the same tick\n      emitOutputs();\n      this.userChange.emit(this.getChangeContext());\n    } else {\n      // But, if the change was initated by something else like a change in input bindings,\n      // we need to wait until next tick to emit the outputs to keep Angular change detection happy\n      setTimeout(() => { emitOutputs(); });\n    }\n  }\n\n  private normaliseModelValues(input: ModelValues): ModelValues {\n    const normalisedInput: ModelValues = new ModelValues();\n    normalisedInput.value = input.value;\n    normalisedInput.highValue = input.highValue;\n\n    if (this.viewOptions.enforceStep) {\n      normalisedInput.value = this.roundStep(normalisedInput.value);\n      if (this.range) {\n        normalisedInput.highValue = this.roundStep(normalisedInput.highValue);\n      }\n    }\n\n    // Don't attempt to normalise further when using steps array (steps may be out of order and that is perfectly fine)\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) || !this.viewOptions.enforceRange) {\n      return normalisedInput;\n    }\n\n    normalisedInput.value = MathHelper.clampToRange(normalisedInput.value, this.viewOptions.floor, this.viewOptions.ceil);\n\n    if (this.range) {\n      normalisedInput.highValue = MathHelper.clampToRange(normalisedInput.highValue, this.viewOptions.floor, this.viewOptions.ceil);\n    }\n\n    // Make sure that range slider invariant (value <= highValue) is always satisfied\n    if (this.range && input.value > input.highValue) {\n      // We know that both values are now clamped correctly, they may just be in the wrong order\n      // So the easy solution is to swap them... except swapping is sometimes disabled in options, so we make the two values the same\n      if (this.viewOptions.noSwitching) {\n        normalisedInput.value = normalisedInput.highValue;\n      } else {\n        const tempValue: number = input.value;\n        normalisedInput.value = input.highValue;\n        normalisedInput.highValue = tempValue;\n      }\n    }\n\n    return normalisedInput;\n  }\n\n  private renormaliseModelValues(): void {\n    const previousModelValues: ModelValues = {\n      value: this.value,\n      highValue: this.highValue\n    };\n    const normalisedModelValues: ModelValues = this.normaliseModelValues(previousModelValues);\n    if (!ModelValues.compare(normalisedModelValues, previousModelValues)) {\n      this.value = normalisedModelValues.value;\n      this.highValue = normalisedModelValues.highValue;\n\n      this.outputModelChangeSubject.next({\n        value: this.value,\n        highValue: this.highValue,\n        forceChange: true,\n        userEventInitiated: false\n      });\n    }\n  }\n\n  private onChangeOptions(): void {\n    if (!this.initHasRun) {\n      return;\n    }\n\n    const previousInputEventsInterval: number = this.viewOptions.inputEventsInterval;\n    const previousOutputEventsInterval: number = this.viewOptions.outputEventsInterval;\n\n    this.applyOptions();\n\n    if (previousInputEventsInterval !== this.viewOptions.inputEventsInterval) {\n      this.unsubscribeInputModelChangeSubject();\n      this.subscribeInputModelChangeSubject(this.viewOptions.inputEventsInterval);\n    }\n\n    if (previousOutputEventsInterval !== this.viewOptions.outputEventsInterval) {\n      this.unsubscribeInputModelChangeSubject();\n      this.subscribeInputModelChangeSubject(this.viewOptions.outputEventsInterval);\n    }\n\n    // With new options, we need to re-normalise model values if necessary\n    this.renormaliseModelValues();\n\n    this.viewLowValue = this.modelValueToViewValue(this.value);\n    if (this.range) {\n      this.viewHighValue = this.modelValueToViewValue(this.highValue);\n    } else {\n      this.viewHighValue = null;\n    }\n\n    this.resetSlider();\n  }\n\n  // Read the user options and apply them to the slider model\n  private applyOptions(): void {\n    this.viewOptions = new Options();\n    Object.assign(this.viewOptions, this.options);\n\n    this.viewOptions.draggableRange = this.range && this.viewOptions.draggableRange;\n    this.viewOptions.draggableRangeOnly = this.range && this.viewOptions.draggableRangeOnly;\n    if (this.viewOptions.draggableRangeOnly) {\n      this.viewOptions.draggableRange = true;\n    }\n\n    this.viewOptions.showTicks = this.viewOptions.showTicks ||\n      this.viewOptions.showTicksValues ||\n      !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray);\n    if (this.viewOptions.showTicks &&\n       (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep) || !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray))) {\n      this.intermediateTicks = true;\n    }\n\n    this.viewOptions.showSelectionBar = this.viewOptions.showSelectionBar ||\n      this.viewOptions.showSelectionBarEnd ||\n      !ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue);\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray)) {\n      this.applyStepsArrayOptions();\n    } else {\n      this.applyFloorCeilOptions();\n    }\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.combineLabels)) {\n      this.viewOptions.combineLabels = (minValue: string, maxValue: string): string => {\n        return minValue + ' - ' + maxValue;\n      };\n    }\n\n    if (this.viewOptions.logScale && this.viewOptions.floor === 0) {\n      throw Error('Can\\'t use floor=0 with logarithmic scale');\n    }\n  }\n\n  private applyStepsArrayOptions(): void {\n    this.viewOptions.floor = 0;\n    this.viewOptions.ceil = this.viewOptions.stepsArray.length - 1;\n    this.viewOptions.step = 1;\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n      this.viewOptions.translate = (modelValue: number): string => {\n        if (this.viewOptions.bindIndexForStepsArray) {\n          return String(this.getStepValue(modelValue));\n        }\n        return String(modelValue);\n      };\n    }\n\n    this.viewOptions.getLegend = (index: number): string => {\n      const step: CustomStepDefinition = this.viewOptions.stepsArray[index];\n      return step.legend;\n    };\n  }\n\n  private applyFloorCeilOptions(): void {\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.step)) {\n      this.viewOptions.step = 1;\n    } else {\n      this.viewOptions.step = +this.viewOptions.step;\n      if (this.viewOptions.step <= 0) {\n        this.viewOptions.step = 1;\n     }\n    }\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.ceil) ||\n        ValueHelper.isNullOrUndefined(this.viewOptions.floor)) {\n      throw Error('floor and ceil options must be supplied');\n    }\n    this.viewOptions.ceil = +this.viewOptions.ceil;\n    this.viewOptions.floor = +this.viewOptions.floor;\n\n    if (ValueHelper.isNullOrUndefined(this.viewOptions.translate)) {\n      this.viewOptions.translate = (value: number): string => String(value);\n    }\n  }\n\n  // Resets slider\n  private resetSlider(): void {\n    this.manageElementsStyle();\n    this.addAccessibility();\n    this.updateCeilLabel();\n    this.updateFloorLabel();\n    this.unbindEvents();\n    this.manageEventsBindings();\n    this.updateDisabledState();\n    this.calculateViewDimensions();\n    this.refocusPointerIfNeeded();\n  }\n\n  // Sets focus on the specified pointer\n  private focusPointer(pointerType: PointerType): void {\n    // If not supplied, use min pointer as default\n    if (pointerType !== PointerType.Min && pointerType !== PointerType.Max) {\n      pointerType = PointerType.Min;\n    }\n\n    if (pointerType === PointerType.Min) {\n      this.minHandleElement.focus();\n    } else if (this.range && pointerType === PointerType.Max) {\n      this.maxHandleElement.focus();\n    }\n  }\n\n  private refocusPointerIfNeeded(): void {\n    if (!ValueHelper.isNullOrUndefined(this.currentFocusPointer)) {\n      this.onPointerFocus(this.currentFocusPointer);\n      const element: SliderHandleDirective = this.getPointerElement(this.currentFocusPointer);\n      element.focus();\n    }\n  }\n\n  // Update each elements style based on options\n  private manageElementsStyle(): void {\n    this.updateScale();\n\n    this.floorLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n    this.ceilLabelElement.setAlwaysHide(this.viewOptions.showTicksValues || this.viewOptions.hideLimitLabels);\n\n    const hideLabelsForTicks: boolean = this.viewOptions.showTicksValues && !this.intermediateTicks;\n    this.minHandleLabelElement.setAlwaysHide(hideLabelsForTicks || this.viewOptions.hidePointerLabels);\n    this.maxHandleLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n    this.combinedLabelElement.setAlwaysHide(hideLabelsForTicks || !this.range || this.viewOptions.hidePointerLabels);\n    this.selectionBarElement.setAlwaysHide(!this.range && !this.viewOptions.showSelectionBar);\n    this.leftOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n    this.rightOuterSelectionBarElement.setAlwaysHide(!this.range || !this.viewOptions.showOuterSelectionBars);\n\n    this.fullBarTransparentClass = this.range && this.viewOptions.showOuterSelectionBars;\n    this.selectionBarDraggableClass = this.viewOptions.draggableRange && !this.viewOptions.onlyBindHandles;\n    this.ticksUnderValuesClass = this.intermediateTicks && this.options.showTicksValues;\n\n    if (this.sliderElementVerticalClass !== this.viewOptions.vertical) {\n      this.updateVerticalState();\n      // The above change in host component class will not be applied until the end of this cycle\n      // However, functions calculating the slider position expect the slider to be already styled as vertical\n      // So as a workaround, we need to reset the slider once again to compute the correct values\n      setTimeout((): void => { this.resetSlider(); });\n    }\n\n    // Changing animate class may interfere with slider reset/initialisation, so we should set it separately,\n    // after all is properly set up\n    if (this.sliderElementAnimateClass !== this.viewOptions.animate) {\n      setTimeout((): void => { this.sliderElementAnimateClass = this.viewOptions.animate; });\n    }\n  }\n\n  // Manage the events bindings based on readOnly and disabled options\n  private manageEventsBindings(): void {\n    if (this.viewOptions.disabled || this.viewOptions.readOnly) {\n      this.unbindEvents();\n    } else {\n      this.bindEvents();\n    }\n  }\n\n  // Set the disabled state based on disabled option\n  private updateDisabledState(): void {\n    this.sliderElementDisabledAttr = this.viewOptions.disabled ? 'disabled' : null;\n  }\n\n  // Set vertical state based on vertical option\n  private updateVerticalState(): void {\n    this.sliderElementVerticalClass = this.viewOptions.vertical;\n    for (const element of this.getAllSliderElements()) {\n      // This is also called before ngAfterInit, so need to check that view child bindings work\n      if (!ValueHelper.isNullOrUndefined(element)) {\n        element.setVertical(this.viewOptions.vertical);\n      }\n    }\n  }\n\n  private updateScale(): void {\n    for (const element of this.getAllSliderElements()) {\n      element.setScale(this.viewOptions.scale);\n    }\n  }\n\n  private getAllSliderElements(): SliderElementDirective[] {\n    return [this.leftOuterSelectionBarElement,\n      this.rightOuterSelectionBarElement,\n      this.fullBarElement,\n      this.selectionBarElement,\n      this.minHandleElement,\n      this.maxHandleElement,\n      this.floorLabelElement,\n      this.ceilLabelElement,\n      this.minHandleLabelElement,\n      this.maxHandleLabelElement,\n      this.combinedLabelElement,\n      this.ticksElement\n    ];\n  }\n\n  // Initialize slider handles positions and labels\n  // Run only once during initialization and every time view port changes size\n  private initHandles(): void {\n    this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n\n    /*\n   the order here is important since the selection bar should be\n   updated after the high handle but before the combined label\n   */\n    if (this.range) {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n    }\n\n    this.updateSelectionBar();\n\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n\n    this.updateTicksScale();\n  }\n\n  // Adds accessibility attributes, run only once during initialization\n  private addAccessibility(): void {\n    this.updateAriaAttributes();\n\n    this.minHandleElement.role = 'slider';\n\n    if ( this.viewOptions.keyboardSupport &&\n      !(this.viewOptions.readOnly || this.viewOptions.disabled) ) {\n      this.minHandleElement.tabindex = '0';\n    } else {\n      this.minHandleElement.tabindex = '';\n    }\n\n    if (this.viewOptions.vertical) {\n      this.minHandleElement.ariaOrientation = 'vertical';\n    }\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabel)) {\n      this.minHandleElement.ariaLabel = this.viewOptions.ariaLabel;\n    } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledBy)) {\n      this.minHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledBy;\n    }\n\n    if (this.range) {\n      this.maxHandleElement.role = 'slider';\n\n      if (this.viewOptions.keyboardSupport &&\n        !(this.viewOptions.readOnly || this.viewOptions.disabled)) {\n        this.maxHandleElement.tabindex = '0';\n      } else {\n        this.maxHandleElement.tabindex = '';\n      }\n\n      this.maxHandleElement.ariaOrientation = this.viewOptions.vertical ? 'vertical' : 'horizontal';\n\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelHigh)) {\n        this.maxHandleElement.ariaLabel = this.viewOptions.ariaLabelHigh;\n      } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.ariaLabelledByHigh)) {\n        this.maxHandleElement.ariaLabelledBy = this.viewOptions.ariaLabelledByHigh;\n      }\n    }\n  }\n\n  // Updates aria attributes according to current values\n  private updateAriaAttributes(): void {\n    this.minHandleElement.ariaValueNow = (+this.value).toString();\n    this.minHandleElement.ariaValueText = this.viewOptions.translate(+this.value, LabelType.Low);\n    this.minHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n    this.minHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n\n    if (this.range) {\n      this.maxHandleElement.ariaValueNow = (+this.highValue).toString();\n      this.maxHandleElement.ariaValueText = this.viewOptions.translate(+this.highValue, LabelType.High);\n      this.maxHandleElement.ariaValueMin = this.viewOptions.floor.toString();\n      this.maxHandleElement.ariaValueMax = this.viewOptions.ceil.toString();\n    }\n  }\n\n  // Calculate dimensions that are dependent on view port size\n  // Run once during initialization and every time view port changes size.\n  private calculateViewDimensions(): void {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.handleDimension)) {\n      this.minHandleElement.setDimension(this.viewOptions.handleDimension);\n    } else {\n      this.minHandleElement.calculateDimension();\n    }\n\n    const handleWidth: number = this.minHandleElement.dimension;\n\n    this.handleHalfDimension = handleWidth / 2;\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.barDimension)) {\n      this.fullBarElement.setDimension(this.viewOptions.barDimension);\n    } else {\n      this.fullBarElement.calculateDimension();\n    }\n\n    this.maxHandlePosition = this.fullBarElement.dimension - handleWidth;\n\n    if (this.initHasRun) {\n      this.updateFloorLabel();\n      this.updateCeilLabel();\n      this.initHandles();\n    }\n  }\n\n  private calculateViewDimensionsAndDetectChanges(): void {\n    this.calculateViewDimensions();\n    this.changeDetectionRef.detectChanges();\n  }\n\n  // Update the ticks position\n  private updateTicksScale(): void {\n    if (!this.viewOptions.showTicks) {\n      return;\n    }\n\n    const ticksArray: number[] = !ValueHelper.isNullOrUndefined(this.viewOptions.ticksArray)\n      ? this.viewOptions.ticksArray\n      : this.getTicksArray();\n    const translate: string = this.viewOptions.vertical ? 'translateY' : 'translateX';\n\n    if (this.viewOptions.rightToLeft) {\n      ticksArray.reverse();\n    }\n\n    const newTicks: Tick[] = ticksArray.map((value: number): Tick => {\n      let position: number = this.valueToPosition(value);\n\n      if (this.viewOptions.vertical) {\n        position = this.maxHandlePosition - position;\n      }\n\n      const translation: string = translate + '(' + Math.round(position) + 'px)';\n      const tick: Tick = new Tick();\n      tick.selected = this.isTickSelected(value);\n      tick.style = {\n        '-webkit-transform': translation,\n        '-moz-transform': translation,\n        '-o-transform': translation,\n        '-ms-transform': translation,\n        transform: translation,\n      };\n      if (tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n        tick.style['background-color'] = this.getSelectionBarColor();\n      }\n      if (!tick.selected && !ValueHelper.isNullOrUndefined(this.viewOptions.getTickColor)) {\n        tick.style['background-color'] = this.getTickColor(value);\n      }\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksTooltip)) {\n        tick.tooltip = this.viewOptions.ticksTooltip(value);\n        tick.tooltipPlacement = this.viewOptions.vertical ? 'right' : 'top';\n      }\n      if (this.viewOptions.showTicksValues && (value % this.viewOptions.tickValueStep === 0)) {\n        tick.value = this.getDisplayValue(value, LabelType.TickValue);\n        if (!ValueHelper.isNullOrUndefined(this.viewOptions.ticksValuesTooltip)) {\n          tick.valueTooltip = this.viewOptions.ticksValuesTooltip(value);\n          tick.valueTooltipPlacement = this.viewOptions.vertical\n            ? 'right'\n            : 'top';\n        }\n      }\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.getLegend)) {\n        const legend: string = this.viewOptions.getLegend(value);\n        if (!ValueHelper.isNullOrUndefined(legend)) {\n          tick.legend = legend;\n        }\n      }\n      return tick;\n    });\n\n    // We should avoid re-creating the ticks array if possible\n    // This both improves performance and makes CSS animations work correctly\n    if (!ValueHelper.isNullOrUndefined(this.ticks) && this.ticks.length === newTicks.length) {\n      for (let i = 0; i  < newTicks.length; ++i) {\n        Object.assign(this.ticks[i], newTicks[i]);\n      }\n    } else {\n      this.ticks = newTicks;\n    }\n\n    this.changeDetectionRef.detectChanges();\n  }\n\n  private getTicksArray(): number[] {\n    const step: number = (!ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) ? this.viewOptions.tickStep : this.viewOptions.step;\n    const ticksArray: number[] = [];\n    for (let value: number = this.viewOptions.floor; value <= this.viewOptions.ceil; value += step) {\n      ticksArray.push(value);\n    }\n    return ticksArray;\n  }\n\n  private isTickSelected(value: number): boolean {\n    if (!this.range) {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n        const center: number = this.viewOptions.showSelectionBarFromValue;\n        if (this.viewLowValue > center &&\n            value >= center &&\n            value <= this.viewLowValue) {\n          return true;\n        } else if (this.viewLowValue < center &&\n                   value <= center &&\n                   value >= this.viewLowValue) {\n          return true;\n        }\n      } else if (this.viewOptions.showSelectionBarEnd) {\n        if (value >= this.viewLowValue) {\n          return true;\n        }\n      } else if (this.viewOptions.showSelectionBar && value <= this.viewLowValue) {\n        return true;\n      }\n    }\n\n    if (this.range && value >= this.viewLowValue && value <= this.viewHighValue) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Update position of the floor label\n  private updateFloorLabel(): void {\n    if (!this.floorLabelElement.alwaysHide) {\n      this.floorLabelElement.setValue(this.getDisplayValue(this.viewOptions.floor, LabelType.Floor));\n      this.floorLabelElement.calculateDimension();\n      const position: number = this.viewOptions.rightToLeft\n        ? this.fullBarElement.dimension - this.floorLabelElement.dimension\n        : 0;\n      this.floorLabelElement.setPosition(position);\n    }\n  }\n\n  // Update position of the ceiling label\n  private updateCeilLabel(): void {\n    if (!this.ceilLabelElement.alwaysHide) {\n      this.ceilLabelElement.setValue(this.getDisplayValue(this.viewOptions.ceil, LabelType.Ceil));\n      this.ceilLabelElement.calculateDimension();\n      const position: number = this.viewOptions.rightToLeft\n        ? 0\n        : this.fullBarElement.dimension - this.ceilLabelElement.dimension;\n      this.ceilLabelElement.setPosition(position);\n    }\n  }\n\n  // Update slider handles and label positions\n  private updateHandles(which: PointerType, newPos: number): void {\n    if (which === PointerType.Min) {\n      this.updateLowHandle(newPos);\n    } else if (which === PointerType.Max) {\n      this.updateHighHandle(newPos);\n    }\n\n    this.updateSelectionBar();\n    this.updateTicksScale();\n    if (this.range) {\n      this.updateCombinedLabel();\n    }\n  }\n\n  // Helper function to work out the position for handle labels depending on RTL or not\n  private getHandleLabelPos(labelType: PointerType, newPos: number): number {\n    const labelDimension: number = (labelType === PointerType.Min)\n      ? this.minHandleLabelElement.dimension\n      : this.maxHandleLabelElement.dimension;\n    const nearHandlePos: number = newPos - labelDimension / 2 + this.handleHalfDimension;\n    const endOfBarPos: number = this.fullBarElement.dimension - labelDimension;\n\n    if (!this.viewOptions.boundPointerLabels) {\n      return nearHandlePos;\n    }\n\n    if ((this.viewOptions.rightToLeft && labelType === PointerType.Min) ||\n       (!this.viewOptions.rightToLeft && labelType === PointerType.Max)) {\n      return Math.min(nearHandlePos, endOfBarPos);\n    } else {\n      return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);\n    }\n  }\n\n  // Update low slider handle position and label\n  private updateLowHandle(newPos: number): void {\n    this.minHandleElement.setPosition(newPos);\n    this.minHandleLabelElement.setValue(this.getDisplayValue(this.viewLowValue, LabelType.Low));\n    this.minHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Min, newPos));\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n      this.minPointerStyle = {\n        backgroundColor: this.getPointerColor(PointerType.Min),\n      };\n    }\n\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n\n  // Update high slider handle position and label\n  private updateHighHandle(newPos: number): void {\n    this.maxHandleElement.setPosition(newPos);\n    this.maxHandleLabelElement.setValue(this.getDisplayValue(this.viewHighValue, LabelType.High));\n    this.maxHandleLabelElement.setPosition(this.getHandleLabelPos(PointerType.Max, newPos));\n\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getPointerColor)) {\n      this.maxPointerStyle = {\n        backgroundColor: this.getPointerColor(PointerType.Max),\n      };\n    }\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n\n  // Show/hide floor/ceiling label\n  private updateFloorAndCeilLabelsVisibility(): void {\n    // Show based only on hideLimitLabels if pointer labels are hidden\n    if (this.viewOptions.hidePointerLabels) {\n      return;\n    }\n    let floorLabelHidden = false;\n    let ceilLabelHidden = false;\n    const isMinLabelAtFloor: boolean = this.isLabelBelowFloorLabel(this.minHandleLabelElement);\n    const isMinLabelAtCeil: boolean = this.isLabelAboveCeilLabel(this.minHandleLabelElement);\n    const isMaxLabelAtCeil: boolean = this.isLabelAboveCeilLabel(this.maxHandleLabelElement);\n    const isCombinedLabelAtFloor: boolean = this.isLabelBelowFloorLabel(this.combinedLabelElement);\n    const isCombinedLabelAtCeil: boolean = this.isLabelAboveCeilLabel(this.combinedLabelElement);\n\n    if (isMinLabelAtFloor) {\n      floorLabelHidden = true;\n      this.floorLabelElement.hide();\n    } else {\n      floorLabelHidden = false;\n      this.floorLabelElement.show();\n    }\n\n    if (isMinLabelAtCeil) {\n      ceilLabelHidden = true;\n      this.ceilLabelElement.hide();\n    } else {\n      ceilLabelHidden = false;\n      this.ceilLabelElement.show();\n    }\n\n    if (this.range) {\n      const hideCeil: boolean = this.combinedLabelElement.isVisible() ? isCombinedLabelAtCeil : isMaxLabelAtCeil;\n      const hideFloor: boolean = this.combinedLabelElement.isVisible() ? isCombinedLabelAtFloor : isMinLabelAtFloor;\n\n      if (hideCeil) {\n        this.ceilLabelElement.hide();\n      } else if (!ceilLabelHidden) {\n        this.ceilLabelElement.show();\n      }\n\n      // Hide or show floor label\n      if (hideFloor) {\n        this.floorLabelElement.hide();\n      } else if (!floorLabelHidden) {\n        this.floorLabelElement.show();\n      }\n    }\n  }\n\n  private isLabelBelowFloorLabel(label: SliderLabelDirective): boolean {\n    const pos: number = label.position;\n    const dim: number = label.dimension;\n    const floorPos: number = this.floorLabelElement.position;\n    const floorDim: number = this.floorLabelElement.dimension;\n    return this.viewOptions.rightToLeft\n      ? pos + dim >= floorPos - 2\n      : pos <= floorPos + floorDim + 2;\n  }\n\n  private isLabelAboveCeilLabel(label: SliderLabelDirective): boolean {\n    const pos: number = label.position;\n    const dim: number = label.dimension;\n    const ceilPos: number = this.ceilLabelElement.position;\n    const ceilDim: number = this.ceilLabelElement.dimension;\n    return this.viewOptions.rightToLeft\n      ? pos <= ceilPos + ceilDim + 2\n      : pos + dim >= ceilPos - 2;\n  }\n\n  // Update slider selection bar, combined label and range label\n  private updateSelectionBar(): void {\n    let position = 0;\n    let dimension = 0;\n    const isSelectionBarFromRight: boolean = this.viewOptions.rightToLeft\n        ? !this.viewOptions.showSelectionBarEnd\n        : this.viewOptions.showSelectionBarEnd;\n    const positionForRange: number = this.viewOptions.rightToLeft\n        ? this.maxHandleElement.position + this.handleHalfDimension\n        : this.minHandleElement.position + this.handleHalfDimension;\n\n    if (this.range) {\n      dimension = Math.abs(this.maxHandleElement.position - this.minHandleElement.position);\n      position = positionForRange;\n    } else {\n      if (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue)) {\n        const center: number = this.viewOptions.showSelectionBarFromValue;\n        const centerPosition: number = this.valueToPosition(center);\n        const isModelGreaterThanCenter: boolean = this.viewOptions.rightToLeft\n            ? this.viewLowValue <= center\n            : this.viewLowValue > center;\n        if (isModelGreaterThanCenter) {\n          dimension = this.minHandleElement.position - centerPosition;\n          position = centerPosition + this.handleHalfDimension;\n        } else {\n          dimension = centerPosition - this.minHandleElement.position;\n          position = this.minHandleElement.position + this.handleHalfDimension;\n        }\n      } else if (isSelectionBarFromRight) {\n        dimension = Math.ceil(Math.abs(this.maxHandlePosition - this.minHandleElement.position) + this.handleHalfDimension);\n        position = Math.floor(this.minHandleElement.position + this.handleHalfDimension);\n      } else {\n        dimension = this.minHandleElement.position + this.handleHalfDimension;\n        position = 0;\n      }\n    }\n    this.selectionBarElement.setDimension(dimension);\n    this.selectionBarElement.setPosition(position);\n    if (this.range && this.viewOptions.showOuterSelectionBars) {\n      if (this.viewOptions.rightToLeft) {\n        this.rightOuterSelectionBarElement.setDimension(position);\n        this.rightOuterSelectionBarElement.setPosition(0);\n        this.fullBarElement.calculateDimension();\n        this.leftOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n        this.leftOuterSelectionBarElement.setPosition(position + dimension);\n      } else {\n        this.leftOuterSelectionBarElement.setDimension(position);\n        this.leftOuterSelectionBarElement.setPosition(0);\n        this.fullBarElement.calculateDimension();\n        this.rightOuterSelectionBarElement.setDimension(this.fullBarElement.dimension - (position + dimension));\n        this.rightOuterSelectionBarElement.setPosition(position + dimension);\n      }\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.getSelectionBarColor)) {\n      const color: string = this.getSelectionBarColor();\n      this.barStyle = {\n        backgroundColor: color,\n      };\n    } else if (!ValueHelper.isNullOrUndefined(this.viewOptions.selectionBarGradient)) {\n      const offset: number = (!ValueHelper.isNullOrUndefined(this.viewOptions.showSelectionBarFromValue))\n            ? this.valueToPosition(this.viewOptions.showSelectionBarFromValue)\n            : 0;\n      const reversed: boolean = (offset - position > 0 && !isSelectionBarFromRight) || (offset - position <= 0 && isSelectionBarFromRight);\n      const direction: string = this.viewOptions.vertical\n          ? reversed ? 'bottom' : 'top'\n          : reversed ? 'left' : 'right';\n      this.barStyle = {\n        backgroundImage:\n          'linear-gradient(to ' +\n          direction +\n          ', ' +\n          this.viewOptions.selectionBarGradient.from +\n          ' 0%,' +\n          this.viewOptions.selectionBarGradient.to +\n          ' 100%)',\n      };\n      if (this.viewOptions.vertical) {\n        this.barStyle.backgroundPosition =\n          'center ' +\n          (offset +\n            dimension +\n            position +\n            (reversed ? -this.handleHalfDimension : 0)) +\n          'px';\n        this.barStyle.backgroundSize =\n          '100% ' + (this.fullBarElement.dimension - this.handleHalfDimension) + 'px';\n      } else {\n        this.barStyle.backgroundPosition =\n          offset -\n          position +\n          (reversed ? this.handleHalfDimension : 0) +\n          'px center';\n        this.barStyle.backgroundSize =\n          this.fullBarElement.dimension - this.handleHalfDimension + 'px 100%';\n      }\n    }\n  }\n\n  // Wrapper around the getSelectionBarColor of the user to pass to correct parameters\n  private getSelectionBarColor(): string {\n    if (this.range) {\n      return this.viewOptions.getSelectionBarColor(\n        this.value,\n        this.highValue\n      );\n    }\n    return this.viewOptions.getSelectionBarColor(this.value);\n  }\n\n  // Wrapper around the getPointerColor of the user to pass to  correct parameters\n  private getPointerColor(pointerType: PointerType): string {\n    if (pointerType === PointerType.Max) {\n      return this.viewOptions.getPointerColor(\n        this.highValue,\n        pointerType\n      );\n    }\n    return this.viewOptions.getPointerColor(\n      this.value,\n      pointerType\n    );\n  }\n\n  // Wrapper around the getTickColor of the user to pass to correct parameters\n  private getTickColor(value: number): string {\n    return this.viewOptions.getTickColor(value);\n  }\n\n  // Update combined label position and value\n  private updateCombinedLabel(): void {\n    let isLabelOverlap: boolean = null;\n    if (this.viewOptions.rightToLeft) {\n      isLabelOverlap =\n        this.minHandleLabelElement.position - this.minHandleLabelElement.dimension - 10 <= this.maxHandleLabelElement.position;\n    } else {\n      isLabelOverlap =\n        this.minHandleLabelElement.position + this.minHandleLabelElement.dimension + 10 >= this.maxHandleLabelElement.position;\n    }\n\n    if (isLabelOverlap) {\n      const lowDisplayValue: string = this.getDisplayValue(this.viewLowValue, LabelType.Low);\n      const highDisplayValue: string = this.getDisplayValue(this.viewHighValue, LabelType.High);\n      const combinedLabelValue: string = this.viewOptions.rightToLeft\n        ? this.viewOptions.combineLabels(highDisplayValue, lowDisplayValue)\n        : this.viewOptions.combineLabels(lowDisplayValue, highDisplayValue);\n\n      this.combinedLabelElement.setValue(combinedLabelValue);\n      const pos: number = this.viewOptions.boundPointerLabels\n        ? Math.min(\n            Math.max(\n              this.selectionBarElement.position +\n                this.selectionBarElement.dimension / 2 -\n                this.combinedLabelElement.dimension / 2,\n              0\n            ),\n            this.fullBarElement.dimension - this.combinedLabelElement.dimension\n          )\n        : this.selectionBarElement.position + this.selectionBarElement.dimension / 2 - this.combinedLabelElement.dimension / 2;\n\n      this.combinedLabelElement.setPosition(pos);\n      this.minHandleLabelElement.hide();\n      this.maxHandleLabelElement.hide();\n      this.combinedLabelElement.show();\n    } else {\n      this.updateHighHandle(this.valueToPosition(this.viewHighValue));\n      this.updateLowHandle(this.valueToPosition(this.viewLowValue));\n      this.maxHandleLabelElement.show();\n      this.minHandleLabelElement.show();\n      this.combinedLabelElement.hide();\n    }\n    if (this.viewOptions.autoHideLimitLabels) {\n      this.updateFloorAndCeilLabelsVisibility();\n    }\n  }\n\n  // Return the translated value if a translate function is provided else the original value\n  private getDisplayValue(value: number, which: LabelType): string {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.stepsArray) && !this.viewOptions.bindIndexForStepsArray) {\n      value = this.getStepValue(value);\n    }\n    return this.viewOptions.translate(value, which);\n  }\n\n  // Round value to step and precision based on minValue\n  private roundStep(value: number, customStep?: number): number {\n    const step: number = !ValueHelper.isNullOrUndefined(customStep) ? customStep : this.viewOptions.step;\n    let steppedDifference: number = MathHelper.roundToPrecisionLimit(\n      (value - this.viewOptions.floor) / step, this.viewOptions.precisionLimit);\n    steppedDifference = Math.round(steppedDifference) * step;\n    return MathHelper.roundToPrecisionLimit(this.viewOptions.floor + steppedDifference, this.viewOptions.precisionLimit);\n  }\n\n  // Translate value to pixel position\n  private valueToPosition(val: number): number {\n    let fn: ValueToPositionFunction  = ValueHelper.linearValueToPosition;\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.customValueToPosition)) {\n      fn = this.viewOptions.customValueToPosition;\n    } else if (this.viewOptions.logScale) {\n      fn = ValueHelper.logValueToPosition;\n    }\n\n    val = MathHelper.clampToRange(val, this.viewOptions.floor, this.viewOptions.ceil);\n    let percent: number = fn(val, this.viewOptions.floor, this.viewOptions.ceil);\n    if (ValueHelper.isNullOrUndefined(percent)) {\n      percent = 0;\n    }\n    if (this.viewOptions.rightToLeft) {\n      percent = 1 - percent;\n    }\n    return percent * this.maxHandlePosition;\n  }\n\n  // Translate position to model value\n  private positionToValue(position: number): number {\n    let percent: number = position / this.maxHandlePosition;\n    if (this.viewOptions.rightToLeft) {\n      percent = 1 - percent;\n    }\n    let fn: PositionToValueFunction = ValueHelper.linearPositionToValue;\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.customPositionToValue)) {\n      fn = this.viewOptions.customPositionToValue;\n    } else if (this.viewOptions.logScale) {\n      fn = ValueHelper.logPositionToValue;\n    }\n    const value: number = fn(percent, this.viewOptions.floor, this.viewOptions.ceil);\n    return !ValueHelper.isNullOrUndefined(value) ? value : 0;\n  }\n\n  // Get the X-coordinate or Y-coordinate of an event\n  private getEventXY(event: MouseEvent|TouchEvent, targetTouchId?: number): number {\n    if (event instanceof MouseEvent) {\n      return this.viewOptions.vertical ? event.clientY : event.clientX;\n    }\n\n    let touchIndex = 0;\n    const touches: TouchList = event.touches;\n    if (!ValueHelper.isNullOrUndefined(targetTouchId)) {\n      for (let i = 0; i < touches.length; i++) {\n        if (touches[i].identifier === targetTouchId) {\n          touchIndex = i;\n          break;\n        }\n      }\n    }\n\n    // Return the target touch or if the target touch was not found in the event\n    // returns the coordinates of the first touch\n    return this.viewOptions.vertical ? touches[touchIndex].clientY : touches[touchIndex].clientX;\n  }\n\n  // Compute the event position depending on whether the slider is horizontal or vertical\n  private getEventPosition(event: MouseEvent|TouchEvent, targetTouchId?: number): number {\n    const sliderElementBoundingRect: ClientRect = this.elementRef.nativeElement.getBoundingClientRect();\n\n    const sliderPos: number = this.viewOptions.vertical ?\n      sliderElementBoundingRect.bottom : sliderElementBoundingRect.left;\n    let eventPos = 0;\n    if (this.viewOptions.vertical) {\n      eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;\n    } else {\n      eventPos = this.getEventXY(event, targetTouchId) - sliderPos;\n    }\n    return eventPos * this.viewOptions.scale - this.handleHalfDimension;\n  }\n\n  // Get the handle closest to an event\n  private getNearestHandle(event: MouseEvent|TouchEvent): PointerType {\n    if (!this.range) {\n      return PointerType.Min;\n    }\n\n    const position: number = this.getEventPosition(event);\n    const distanceMin: number = Math.abs(position - this.minHandleElement.position);\n    const distanceMax: number = Math.abs(position - this.maxHandleElement.position);\n\n    if (distanceMin < distanceMax) {\n      return PointerType.Min;\n    } else if (distanceMin > distanceMax) {\n      return PointerType.Max;\n    } else if (!this.viewOptions.rightToLeft) {\n      // if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH\n      return position < this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n    }\n    // reverse in rtl\n    return position > this.minHandleElement.position ? PointerType.Min : PointerType.Max;\n  }\n\n  // Bind mouse and touch events to slider handles\n  private bindEvents(): void {\n    const draggableRange: boolean = this.viewOptions.draggableRange;\n\n    if (!this.viewOptions.onlyBindHandles) {\n      this.selectionBarElement.on('mousedown',\n        (event: MouseEvent): void => this.onBarStart(null, draggableRange, event, true, true, true)\n      );\n    }\n\n    if (this.viewOptions.draggableRangeOnly) {\n      this.minHandleElement.on('mousedown',\n        (event: MouseEvent): void => this.onBarStart(PointerType.Min, draggableRange, event, true, true)\n      );\n      this.maxHandleElement.on('mousedown',\n        (event: MouseEvent): void => this.onBarStart(PointerType.Max, draggableRange, event, true, true)\n      );\n    } else {\n      this.minHandleElement.on('mousedown',\n        (event: MouseEvent): void => this.onStart(PointerType.Min, event, true, true)\n      );\n\n      if (this.range) {\n        this.maxHandleElement.on('mousedown',\n          (event: MouseEvent): void => this.onStart(PointerType.Max, event, true, true)\n        );\n      }\n      if (!this.viewOptions.onlyBindHandles) {\n        this.fullBarElement.on('mousedown',\n          (event: MouseEvent): void => this.onStart(null, event, true, true, true)\n        );\n        this.ticksElement.on('mousedown',\n          (event: MouseEvent): void => this.onStart(null, event, true, true, true, true)\n        );\n      }\n    }\n\n    if (!this.viewOptions.onlyBindHandles) {\n      this.selectionBarElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onBarStart(null, draggableRange, event, true, true, true)\n      );\n    }\n    if (this.viewOptions.draggableRangeOnly) {\n      this.minHandleElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onBarStart(PointerType.Min, draggableRange, event, true, true)\n      );\n      this.maxHandleElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onBarStart(PointerType.Max, draggableRange, event, true, true)\n      );\n    } else {\n      this.minHandleElement.onPassive('touchstart',\n        (event: TouchEvent): void => this.onStart(PointerType.Min, event, true, true)\n      );\n      if (this.range) {\n        this.maxHandleElement.onPassive('touchstart',\n          (event: TouchEvent): void => this.onStart(PointerType.Max, event, true, true)\n        );\n      }\n      if (!this.viewOptions.onlyBindHandles) {\n        this.fullBarElement.onPassive('touchstart',\n          (event: TouchEvent): void => this.onStart(null, event, true, true, true)\n        );\n        this.ticksElement.onPassive('touchstart',\n          (event: TouchEvent): void => this.onStart(null, event, false, false, true, true)\n        );\n      }\n    }\n\n    if (this.viewOptions.keyboardSupport) {\n      this.minHandleElement.on('focus', (): void => this.onPointerFocus(PointerType.Min));\n      if (this.range) {\n        this.maxHandleElement.on('focus', (): void => this.onPointerFocus(PointerType.Max));\n      }\n    }\n  }\n\n  // Unbind mouse and touch events to slider handles\n  private unbindEvents(): void {\n    this.unsubscribeOnMove();\n    this.unsubscribeOnEnd();\n\n    for (const element of this.getAllSliderElements()) {\n      element.off();\n    }\n  }\n\n  private onBarStart(pointerType: PointerType, draggableRange: boolean, event: MouseEvent|TouchEvent,\n                     bindMove: boolean, bindEnd: boolean, simulateImmediateMove?: boolean, simulateImmediateEnd?: boolean): void {\n    if (draggableRange) {\n      this.onDragStart(pointerType, event, bindMove, bindEnd);\n    } else {\n      this.onStart(pointerType, event, bindMove, bindEnd, simulateImmediateMove, simulateImmediateEnd);\n    }\n  }\n\n  // onStart event handler\n  private onStart(pointerType: PointerType, event: MouseEvent|TouchEvent,\n                  bindMove: boolean, bindEnd: boolean, simulateImmediateMove?: boolean, simulateImmediateEnd?: boolean): void {\n    event.stopPropagation();\n    // Only call preventDefault() when handling non-passive events (passive events don't need it)\n    if (!CompatibilityHelper.isTouchEvent(event) || !detectPassiveEvents.hasSupport) {\n      event.preventDefault();\n    }\n\n    // We have to do this in case the HTML where the sliders are on\n    // have been animated into view.\n    this.calculateViewDimensions();\n\n    if (ValueHelper.isNullOrUndefined(pointerType)) {\n      pointerType = this.getNearestHandle(event);\n    }\n\n    this.currentTrackingPointer = pointerType;\n\n    const pointerElement: SliderHandleDirective = this.getPointerElement(pointerType);\n    pointerElement.active = true;\n\n    if (this.viewOptions.keyboardSupport) {\n      pointerElement.focus();\n    }\n\n    if (bindMove) {\n      this.unsubscribeOnMove();\n\n      const onMoveCallback: ((e: MouseEvent|TouchEvent) => void) =\n        (e: MouseEvent|TouchEvent): void => this.dragging.active ? this.onDragMove(e) : this.onMove(e);\n\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        this.onMoveEventListener = this.eventListenerHelper.attachPassiveEventListener(\n          document, 'touchmove', onMoveCallback, this.viewOptions.touchEventsInterval);\n      } else {\n        this.onMoveEventListener = this.eventListenerHelper.attachEventListener(\n          document, 'mousemove', onMoveCallback, this.viewOptions.mouseEventsInterval);\n      }\n    }\n\n    if (bindEnd) {\n      this.unsubscribeOnEnd();\n\n      const onEndCallback: ((e: MouseEvent|TouchEvent) => void) =\n        (e: MouseEvent|TouchEvent): void => this.onEnd(e);\n\n      if (CompatibilityHelper.isTouchEvent(event)) {\n        this.onEndEventListener = this.eventListenerHelper.attachPassiveEventListener(document, 'touchend', onEndCallback);\n      } else {\n        this.onEndEventListener = this.eventListenerHelper.attachEventListener(document, 'mouseup', onEndCallback);\n      }\n    }\n\n    this.userChangeStart.emit(this.getChangeContext());\n\n    if (CompatibilityHelper.isTouchEvent(event) && !ValueHelper.isNullOrUndefined((event as TouchEvent).changedTouches)) {\n      // Store the touch identifier\n      if (ValueHelper.isNullOrUndefined(this.touchId)) {\n        this.touchId = (event as TouchEvent).changedTouches[0].identifier;\n      }\n    }\n\n    // Click events, either with mouse or touch gesture are weird. Sometimes they result in full\n    // start, move, end sequence, and sometimes, they don't - they only invoke mousedown\n    // As a workaround, we simulate the first move event and the end event if it's necessary\n    if (simulateImmediateMove) {\n      this.onMove(event, true);\n    }\n\n    if (simulateImmediateEnd) {\n      this.onEnd(event);\n    }\n  }\n\n  // onMove event handler\n  private onMove(event: MouseEvent|TouchEvent, fromTick?: boolean): void {\n    let touchForThisSlider: Touch = null;\n\n    if (CompatibilityHelper.isTouchEvent(event)) {\n      const changedTouches: TouchList = (event as TouchEvent).changedTouches;\n      // tslint:disable-next-line: prefer-for-of\n      for (let i = 0; i < changedTouches.length; i++) {\n        if (changedTouches[i].identifier === this.touchId) {\n          touchForThisSlider = changedTouches[i];\n          break;\n        }\n      }\n\n      if (ValueHelper.isNullOrUndefined(touchForThisSlider)) {\n        return;\n      }\n    }\n\n    const newPos: number = !ValueHelper.isNullOrUndefined(touchForThisSlider)\n      ? this.getEventPosition(event, touchForThisSlider.identifier)\n      : this.getEventPosition(event);\n    let newValue: number;\n    const ceilValue: number = this.viewOptions.rightToLeft\n        ? this.viewOptions.floor\n        : this.viewOptions.ceil;\n    const floorValue: number = this.viewOptions.rightToLeft ? this.viewOptions.ceil : this.viewOptions.floor;\n\n    if (newPos <= 0) {\n      newValue = floorValue;\n    } else if (newPos >= this.maxHandlePosition) {\n      newValue = ceilValue;\n    } else {\n      newValue = this.positionToValue(newPos);\n      if (fromTick && !ValueHelper.isNullOrUndefined(this.viewOptions.tickStep)) {\n        newValue = this.roundStep(newValue, this.viewOptions.tickStep);\n      } else {\n        newValue = this.roundStep(newValue);\n      }\n    }\n    this.positionTrackingHandle(newValue);\n  }\n\n  private onEnd(event: MouseEvent|TouchEvent): void {\n    if (CompatibilityHelper.isTouchEvent(event)) {\n      const changedTouches: TouchList = (event as TouchEvent).changedTouches;\n      if (changedTouches[0].identifier !== this.touchId) {\n        return;\n      }\n    }\n\n    this.touchId = null;\n\n    if (!this.viewOptions.keyboardSupport) {\n      this.minHandleElement.active = false;\n      this.maxHandleElement.active = false;\n      this.currentTrackingPointer = null;\n    }\n    this.dragging.active = false;\n\n    this.unsubscribeOnMove();\n    this.unsubscribeOnEnd();\n\n    this.userChangeEnd.emit(this.getChangeContext());\n  }\n\n  private onPointerFocus(pointerType: PointerType): void {\n    const pointerElement: SliderHandleDirective = this.getPointerElement(pointerType);\n    pointerElement.on('blur', (): void => this.onPointerBlur(pointerElement));\n    pointerElement.on('keydown', (event: KeyboardEvent): void => this.onKeyboardEvent(event));\n    pointerElement.on('keyup', (): void => this.onKeyUp());\n    pointerElement.active = true;\n\n    this.currentTrackingPointer = pointerType;\n    this.currentFocusPointer = pointerType;\n    this.firstKeyDown = true;\n  }\n\n  private onKeyUp(): void {\n    this.firstKeyDown = true;\n    this.userChangeEnd.emit(this.getChangeContext());\n  }\n\n  private onPointerBlur(pointer: SliderHandleDirective): void {\n    pointer.off('blur');\n    pointer.off('keydown');\n    pointer.off('keyup');\n    pointer.active = false;\n    if (ValueHelper.isNullOrUndefined(this.touchId)) {\n      this.currentTrackingPointer = null;\n      this.currentFocusPointer = null;\n    }\n  }\n\n  private getKeyActions(currentValue: number): {[key: string]: number} {\n    const valueRange: number = this.viewOptions.ceil - this.viewOptions.floor;\n\n    let increaseStep: number = currentValue + this.viewOptions.step;\n    let decreaseStep: number = currentValue - this.viewOptions.step;\n    let increasePage: number = currentValue + valueRange / 10;\n    let decreasePage: number = currentValue - valueRange / 10;\n\n    if (this.viewOptions.reversedControls) {\n      increaseStep = currentValue - this.viewOptions.step;\n      decreaseStep = currentValue + this.viewOptions.step;\n      increasePage = currentValue - valueRange / 10;\n      decreasePage = currentValue + valueRange / 10;\n    }\n\n    // Left to right default actions\n    const actions: {[key: string]: number} = {\n      UP: increaseStep,\n      DOWN: decreaseStep,\n      LEFT: decreaseStep,\n      RIGHT: increaseStep,\n      PAGEUP: increasePage,\n      PAGEDOWN: decreasePage,\n      HOME: this.viewOptions.reversedControls ? this.viewOptions.ceil : this.viewOptions.floor,\n      END: this.viewOptions.reversedControls ? this.viewOptions.floor : this.viewOptions.ceil,\n    };\n    // right to left means swapping right and left arrows\n    if (this.viewOptions.rightToLeft) {\n      actions.LEFT = increaseStep;\n      actions.RIGHT = decreaseStep;\n      // right to left and vertical means we also swap up and down\n      if (this.viewOptions.vertical) {\n        actions.UP = decreaseStep;\n        actions.DOWN = increaseStep;\n      }\n    }\n    return actions;\n  }\n\n  private onKeyboardEvent(event: KeyboardEvent): void {\n    const currentValue: number = this.getCurrentTrackingValue();\n    const keyCode: number = !ValueHelper.isNullOrUndefined(event.keyCode)\n      ? event.keyCode\n      : event.which;\n    const keys: {[keyCode: number]: string} = {\n        38: 'UP',\n        40: 'DOWN',\n        37: 'LEFT',\n        39: 'RIGHT',\n        33: 'PAGEUP',\n        34: 'PAGEDOWN',\n        36: 'HOME',\n        35: 'END',\n      };\n    const actions: {[key: string]: number} = this.getKeyActions(currentValue);\n    const key: string = keys[keyCode];\n    const action: number = actions[key];\n\n    if (ValueHelper.isNullOrUndefined(action) || ValueHelper.isNullOrUndefined(this.currentTrackingPointer)) {\n      return;\n    }\n    event.preventDefault();\n\n    if (this.firstKeyDown) {\n      this.firstKeyDown = false;\n      this.userChangeStart.emit(this.getChangeContext());\n    }\n\n    const actionValue: number = MathHelper.clampToRange(action, this.viewOptions.floor, this.viewOptions.ceil);\n    const newValue: number = this.roundStep(actionValue);\n    if (!this.viewOptions.draggableRangeOnly) {\n      this.positionTrackingHandle(newValue);\n    } else {\n      const difference: number = this.viewHighValue - this.viewLowValue;\n      let newMinValue: number;\n      let newMaxValue: number;\n\n      if (this.currentTrackingPointer === PointerType.Min) {\n        newMinValue = newValue;\n        newMaxValue = newValue + difference;\n        if (newMaxValue > this.viewOptions.ceil) {\n          newMaxValue = this.viewOptions.ceil;\n          newMinValue = newMaxValue - difference;\n        }\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        newMaxValue = newValue;\n        newMinValue = newValue - difference;\n        if (newMinValue < this.viewOptions.floor) {\n          newMinValue = this.viewOptions.floor;\n          newMaxValue = newMinValue + difference;\n        }\n      }\n      this.positionTrackingBar(newMinValue, newMaxValue);\n    }\n  }\n\n  // onDragStart event handler, handles dragging of the middle bar\n  private onDragStart(pointerType: PointerType, event: MouseEvent|TouchEvent,\n                      bindMove: boolean, bindEnd: boolean): void {\n    const position: number = this.getEventPosition(event);\n\n    this.dragging = new Dragging();\n    this.dragging.active = true;\n    this.dragging.value = this.positionToValue(position);\n    this.dragging.difference = this.viewHighValue - this.viewLowValue;\n    this.dragging.lowLimit = this.viewOptions.rightToLeft\n        ? this.minHandleElement.position - position\n        : position - this.minHandleElement.position;\n    this.dragging.highLimit = this.viewOptions.rightToLeft\n        ? position - this.maxHandleElement.position\n        : this.maxHandleElement.position - position;\n\n    this.onStart(pointerType, event, bindMove, bindEnd);\n  }\n\n  /** Get min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft */\n  private getMinValue(newPos: number, outOfBounds: boolean, isAbove: boolean): number {\n    const isRTL: boolean = this.viewOptions.rightToLeft;\n    let value: number = null;\n\n    if (outOfBounds) {\n      if (isAbove) {\n        value = isRTL\n          ? this.viewOptions.floor\n          : this.viewOptions.ceil - this.dragging.difference;\n      } else {\n        value = isRTL\n          ? this.viewOptions.ceil - this.dragging.difference\n          : this.viewOptions.floor;\n      }\n    } else {\n      value = isRTL\n        ? this.positionToValue(newPos + this.dragging.lowLimit)\n        : this.positionToValue(newPos - this.dragging.lowLimit);\n    }\n    return this.roundStep(value);\n  }\n\n  /** Get max value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft */\n  private getMaxValue(newPos: number, outOfBounds: boolean, isAbove: boolean): number {\n    const isRTL: boolean = this.viewOptions.rightToLeft;\n    let value: number = null;\n\n    if (outOfBounds) {\n      if (isAbove) {\n        value = isRTL\n          ? this.viewOptions.floor + this.dragging.difference\n          : this.viewOptions.ceil;\n      } else {\n        value = isRTL\n          ? this.viewOptions.ceil\n          : this.viewOptions.floor + this.dragging.difference;\n      }\n    } else {\n      if (isRTL) {\n        value =\n          this.positionToValue(newPos + this.dragging.lowLimit) +\n          this.dragging.difference;\n      } else {\n        value =\n          this.positionToValue(newPos - this.dragging.lowLimit) +\n          this.dragging.difference;\n      }\n    }\n\n    return this.roundStep(value);\n  }\n\n  private onDragMove(event?: MouseEvent|TouchEvent): void {\n    const newPos: number = this.getEventPosition(event);\n\n    let ceilLimit: number;\n    let floorLimit: number;\n    let floorHandleElement: SliderHandleDirective;\n    let ceilHandleElement: SliderHandleDirective;\n    if (this.viewOptions.rightToLeft) {\n      ceilLimit = this.dragging.lowLimit;\n      floorLimit = this.dragging.highLimit;\n      floorHandleElement = this.maxHandleElement;\n      ceilHandleElement = this.minHandleElement;\n    } else {\n      ceilLimit = this.dragging.highLimit;\n      floorLimit = this.dragging.lowLimit;\n      floorHandleElement = this.minHandleElement;\n      ceilHandleElement = this.maxHandleElement;\n    }\n\n    const isUnderFloorLimit: boolean = (newPos <= floorLimit);\n    const isOverCeilLimit: boolean = (newPos >= this.maxHandlePosition - ceilLimit);\n\n    let newMinValue: number;\n    let newMaxValue: number;\n    if (isUnderFloorLimit) {\n      if (floorHandleElement.position === 0) {\n        return;\n      }\n      newMinValue = this.getMinValue(newPos, true, false);\n      newMaxValue = this.getMaxValue(newPos, true, false);\n    } else if (isOverCeilLimit) {\n      if (ceilHandleElement.position === this.maxHandlePosition) {\n        return;\n      }\n      newMaxValue = this.getMaxValue(newPos, true, true);\n      newMinValue = this.getMinValue(newPos, true, true);\n    } else {\n      newMinValue = this.getMinValue(newPos, false, false);\n      newMaxValue = this.getMaxValue(newPos, false, false);\n    }\n\n    this.positionTrackingBar(newMinValue, newMaxValue);\n  }\n\n  // Set the new value and position for the entire bar\n  private positionTrackingBar(newMinValue: number, newMaxValue: number): void {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) &&\n        newMinValue < this.viewOptions.minLimit) {\n      newMinValue = this.viewOptions.minLimit;\n      newMaxValue = MathHelper.roundToPrecisionLimit(newMinValue + this.dragging.difference, this.viewOptions.precisionLimit);\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) &&\n        newMaxValue > this.viewOptions.maxLimit) {\n      newMaxValue = this.viewOptions.maxLimit;\n      newMinValue = MathHelper.roundToPrecisionLimit(newMaxValue - this.dragging.difference, this.viewOptions.precisionLimit);\n    }\n\n    this.viewLowValue = newMinValue;\n    this.viewHighValue = newMaxValue;\n    this.applyViewChange();\n    this.updateHandles(PointerType.Min, this.valueToPosition(newMinValue));\n    this.updateHandles(PointerType.Max, this.valueToPosition(newMaxValue));\n  }\n\n  // Set the new value and position to the current tracking handle\n  private positionTrackingHandle(newValue: number): void {\n    newValue = this.applyMinMaxLimit(newValue);\n    if (this.range) {\n      if (this.viewOptions.pushRange) {\n        newValue = this.applyPushRange(newValue);\n      } else {\n        if (this.viewOptions.noSwitching) {\n          if (this.currentTrackingPointer === PointerType.Min &&\n              newValue > this.viewHighValue) {\n            newValue = this.applyMinMaxRange(this.viewHighValue);\n          } else if (this.currentTrackingPointer === PointerType.Max &&\n                     newValue < this.viewLowValue) {\n            newValue = this.applyMinMaxRange(this.viewLowValue);\n          }\n        }\n        newValue = this.applyMinMaxRange(newValue);\n        /* This is to check if we need to switch the min and max handles */\n        if (this.currentTrackingPointer === PointerType.Min && newValue > this.viewHighValue) {\n          this.viewLowValue = this.viewHighValue;\n          this.applyViewChange();\n          this.updateHandles(PointerType.Min, this.maxHandleElement.position);\n          this.updateAriaAttributes();\n          this.currentTrackingPointer = PointerType.Max;\n          this.minHandleElement.active = false;\n          this.maxHandleElement.active = true;\n          if (this.viewOptions.keyboardSupport) {\n            this.maxHandleElement.focus();\n          }\n        } else if (this.currentTrackingPointer === PointerType.Max &&\n                   newValue < this.viewLowValue) {\n          this.viewHighValue = this.viewLowValue;\n          this.applyViewChange();\n          this.updateHandles(PointerType.Max, this.minHandleElement.position);\n          this.updateAriaAttributes();\n          this.currentTrackingPointer = PointerType.Min;\n          this.maxHandleElement.active = false;\n          this.minHandleElement.active = true;\n          if (this.viewOptions.keyboardSupport) {\n            this.minHandleElement.focus();\n          }\n        }\n      }\n    }\n\n    if (this.getCurrentTrackingValue() !== newValue) {\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewLowValue = newValue;\n        this.applyViewChange();\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewHighValue = newValue;\n        this.applyViewChange();\n      }\n      this.updateHandles(this.currentTrackingPointer, this.valueToPosition(newValue));\n      this.updateAriaAttributes();\n    }\n  }\n\n  private applyMinMaxLimit(newValue: number): number {\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minLimit) && newValue < this.viewOptions.minLimit) {\n      return this.viewOptions.minLimit;\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxLimit) && newValue > this.viewOptions.maxLimit) {\n      return this.viewOptions.maxLimit;\n    }\n    return newValue;\n  }\n\n  private applyMinMaxRange(newValue: number): number {\n    const oppositeValue: number = (this.currentTrackingPointer === PointerType.Min)\n      ? this.viewHighValue\n      : this.viewLowValue;\n    const difference: number = Math.abs(newValue - oppositeValue);\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange)) {\n      if (difference < this.viewOptions.minRange) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.minRange, this.viewOptions.precisionLimit);\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.minRange, this.viewOptions.precisionLimit);\n        }\n      }\n    }\n    if (!ValueHelper.isNullOrUndefined(this.viewOptions.maxRange)) {\n      if (difference > this.viewOptions.maxRange) {\n        if (this.currentTrackingPointer === PointerType.Min) {\n          return MathHelper.roundToPrecisionLimit(this.viewHighValue - this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n        } else if (this.currentTrackingPointer === PointerType.Max) {\n          return MathHelper.roundToPrecisionLimit(this.viewLowValue + this.viewOptions.maxRange, this.viewOptions.precisionLimit);\n        }\n      }\n    }\n    return newValue;\n  }\n\n  private applyPushRange(newValue: number): number {\n    const difference: number = (this.currentTrackingPointer === PointerType.Min)\n          ? this.viewHighValue - newValue\n          : newValue - this.viewLowValue;\n    const minRange: number = (!ValueHelper.isNullOrUndefined(this.viewOptions.minRange))\n          ? this.viewOptions.minRange\n          : this.viewOptions.step;\n    const maxRange: number = this.viewOptions.maxRange;\n    // if smaller than minRange\n    if (difference < minRange) {\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewHighValue = MathHelper.roundToPrecisionLimit(\n          Math.min(newValue + minRange, this.viewOptions.ceil), this.viewOptions.precisionLimit);\n        newValue = MathHelper.roundToPrecisionLimit(this.viewHighValue - minRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue));\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewLowValue = MathHelper.roundToPrecisionLimit(\n          Math.max(newValue - minRange, this.viewOptions.floor), this.viewOptions.precisionLimit);\n        newValue = MathHelper.roundToPrecisionLimit(this.viewLowValue + minRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n      }\n      this.updateAriaAttributes();\n    } else if (!ValueHelper.isNullOrUndefined(maxRange) && difference > maxRange) {\n      // if greater than maxRange\n      if (this.currentTrackingPointer === PointerType.Min) {\n        this.viewHighValue = MathHelper.roundToPrecisionLimit(newValue + maxRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Max, this.valueToPosition(this.viewHighValue)\n        );\n      } else if (this.currentTrackingPointer === PointerType.Max) {\n        this.viewLowValue = MathHelper.roundToPrecisionLimit(newValue - maxRange, this.viewOptions.precisionLimit);\n        this.applyViewChange();\n        this.updateHandles(PointerType.Min, this.valueToPosition(this.viewLowValue));\n      }\n      this.updateAriaAttributes();\n    }\n    return newValue;\n  }\n\n  private getChangeContext(): ChangeContext {\n    const changeContext: ChangeContext = new ChangeContext();\n    changeContext.pointerType = this.currentTrackingPointer;\n    changeContext.value = +this.value;\n    if (this.range) {\n      changeContext.highValue = +this.highValue;\n    }\n    return changeContext;\n  }\n}\n","import { Component, Input, TemplateRef } from '@angular/core';\n\n@Component({\n  selector: 'ngx-slider-tooltip-wrapper',\n  templateUrl: './tooltip-wrapper.component.html',\n  styleUrls: ['./tooltip-wrapper.component.scss']\n})\nexport class TooltipWrapperComponent {\n  @Input()\n  template: TemplateRef<any>;\n\n  @Input()\n  tooltip: string;\n\n  @Input()\n  placement: string;\n\n  @Input()\n  content: string;\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { SliderComponent } from './slider.component';\nimport { SliderElementDirective } from '../directives/slider-element.directive';\nimport { SliderHandleDirective } from '../directives/slider-handle.directive';\nimport { SliderLabelDirective } from '../directives/slider-label.directive';\nimport { TooltipWrapperComponent } from '../tooltip-wrapper/tooltip-wrapper.component';\n\n/**\n * NgxSlider module\n *\n * The module exports the slider component\n */\n@NgModule({\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    SliderComponent,\n    SliderElementDirective,\n    SliderHandleDirective,\n    SliderLabelDirective,\n    TooltipWrapperComponent\n  ],\n  exports: [\n    SliderComponent\n  ]\n})\nexport class NgxSliderModule { }\n"]}