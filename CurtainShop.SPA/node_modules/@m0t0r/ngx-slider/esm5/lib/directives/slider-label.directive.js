/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/slider-label.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __extends } from "tslib";
import { Directive, ElementRef, Renderer2 } from '@angular/core';
import { SliderElementDirective } from './slider-element.directive';
import { ValueHelper } from '../helpers/value-helper';
var SliderLabelDirective = /** @class */ (function (_super) {
    __extends(SliderLabelDirective, _super);
    function SliderLabelDirective(elemRef, renderer) {
        var _this = _super.call(this, elemRef, renderer) || this;
        // tslint:disable-next-line: variable-name
        _this._value = null;
        return _this;
    }
    Object.defineProperty(SliderLabelDirective.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    SliderLabelDirective.prototype.setValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var recalculateDimension = false;
        if (!this.alwaysHide &&
            (ValueHelper.isNullOrUndefined(this.value) ||
                this.value.length !== value.length ||
                (this.value.length > 0 && this.dimension === 0))) {
            recalculateDimension = true;
        }
        this._value = value;
        this.elemRef.nativeElement.innerHTML = value;
        // Update dimension only when length of the label have changed
        if (recalculateDimension) {
            this.calculateDimension();
        }
    };
    SliderLabelDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngxSliderLabel]'
                },] }
    ];
    /** @nocollapse */
    SliderLabelDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    return SliderLabelDirective;
}(SliderElementDirective));
export { SliderLabelDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    SliderLabelDirective.prototype._value;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLWxhYmVsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BtMHQwci9uZ3gtc2xpZGVyLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvc2xpZGVyLWxhYmVsLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDakUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDcEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRXREO0lBRzBDLHdDQUFzQjtJQU85RCw4QkFBWSxPQUFtQixFQUFFLFFBQW1CO1FBQXBELFlBQ0Usa0JBQU0sT0FBTyxFQUFFLFFBQVEsQ0FBQyxTQUN6Qjs7UUFQTyxZQUFNLEdBQVcsSUFBSSxDQUFDOztJQU85QixDQUFDO0lBTkQsc0JBQUksdUNBQUs7Ozs7UUFBVDtZQUNFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDOzs7T0FBQTs7Ozs7SUFNRCx1Q0FBUTs7OztJQUFSLFVBQVMsS0FBYTs7WUFDaEIsb0JBQW9CLEdBQUcsS0FBSztRQUVoQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVU7WUFDaEIsQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDekMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE1BQU07Z0JBQ2xDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNyRCxvQkFBb0IsR0FBRyxJQUFJLENBQUM7U0FDN0I7UUFFRCxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBRTdDLDhEQUE4RDtRQUM5RCxJQUFJLG9CQUFvQixFQUFFO1lBQ3hCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1NBQzNCO0lBQ0gsQ0FBQzs7Z0JBL0JGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsa0JBQWtCO2lCQUM3Qjs7OztnQkFObUIsVUFBVTtnQkFBRSxTQUFTOztJQW9DekMsMkJBQUM7Q0FBQSxBQWhDRCxDQUcwQyxzQkFBc0IsR0E2Qi9EO1NBN0JZLG9CQUFvQjs7Ozs7O0lBRS9CLHNDQUE4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTbGlkZXJFbGVtZW50RGlyZWN0aXZlIH0gZnJvbSAnLi9zbGlkZXItZWxlbWVudC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmFsdWVIZWxwZXIgfSBmcm9tICcuLi9oZWxwZXJzL3ZhbHVlLWhlbHBlcic7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuZ3hTbGlkZXJMYWJlbF0nXG59KVxuZXhwb3J0IGNsYXNzIFNsaWRlckxhYmVsRGlyZWN0aXZlIGV4dGVuZHMgU2xpZGVyRWxlbWVudERpcmVjdGl2ZSB7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogdmFyaWFibGUtbmFtZVxuICBwcml2YXRlIF92YWx1ZTogc3RyaW5nID0gbnVsbDtcbiAgZ2V0IHZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZWxlbVJlZjogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgIHN1cGVyKGVsZW1SZWYsIHJlbmRlcmVyKTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgcmVjYWxjdWxhdGVEaW1lbnNpb24gPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5hbHdheXNIaWRlICYmXG4gICAgICAgIChWYWx1ZUhlbHBlci5pc051bGxPclVuZGVmaW5lZCh0aGlzLnZhbHVlKSB8fFxuICAgICAgICAgdGhpcy52YWx1ZS5sZW5ndGggIT09IHZhbHVlLmxlbmd0aCB8fFxuICAgICAgICAgKHRoaXMudmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLmRpbWVuc2lvbiA9PT0gMCkpKSB7XG4gICAgICByZWNhbGN1bGF0ZURpbWVuc2lvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmVsZW1SZWYubmF0aXZlRWxlbWVudC5pbm5lckhUTUwgPSB2YWx1ZTtcblxuICAgIC8vIFVwZGF0ZSBkaW1lbnNpb24gb25seSB3aGVuIGxlbmd0aCBvZiB0aGUgbGFiZWwgaGF2ZSBjaGFuZ2VkXG4gICAgaWYgKHJlY2FsY3VsYXRlRGltZW5zaW9uKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZURpbWVuc2lvbigpO1xuICAgIH1cbiAgfVxufVxuIl19